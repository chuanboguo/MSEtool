{
    "collab_server" : "",
    "contents" : "# ===================================================================\n# === Ancilary indicators ===========================================\n# ===================================================================\n\nslp<-function(x,mat,ind){\n\n  lm(y~x1,data.frame(x1=1:length(ind),y=log(mat[x,ind])))$coef[2]\n\n}\n\nAAV<-function(x,mat,ind){\n  ni<-length(ind)\n  mean(abs((mat[x,ind[2:ni]]-mat[x,ind[1:(ni-1)]])/mat[x,ind[1:(ni-1)]]))\n}\n\nmu<-function(x,mat,ind){\n  mean(mat[x,ind])\n}\n\ngetinds<-function(PPD,styr,res){\n\n  nsim<-dim(PPD@Cat)[1]\n  proyears<-dim(PPD@Cat)[2]-styr+1\n\n  if(res>proyears)message(paste0(\"The temporal resolution for posterior predictive data calculation (\",res,\") is higher than the number of projected years (\",proyears,\"). Only one time step of indicators are calculated for \",proyears, \" projected years.\"))\n  np<-floor(proyears/res)\n\n  tsd<- c(\"Cat\",\"Cat\",\"Cat\", \"Ind\",\"ML\")     #, \"Lc\")\n  stat<-c(\"slp\",\"AAV\",\"mu\",  \"slp\",  \"slp\")  #,\"slp\")\n  ntsd<-length(tsd)\n  inds<-array(NA,c(ntsd,np,nsim))\n\n  for(i in 1:ntsd){\n    for(pp in 1:np){\n      ind<-styr+((pp-1)*res)+1:res\n      inds[i,pp,]<-sapply(1:nsim,get(stat[i]),mat=slot(PPD,tsd[i]),ind=ind)\n    }\n  }\n\n  inds\n\n}\n\nCC<-function(indPPD,indData,pp=1,nams=c(\"YS\", \"AAVY\",\"YM\",\"IS\",\"MLS\"),res){\n\n  namst<-paste(rep(nams,pp),rep((1:pp)*res,each=length(nams)))\n  cols<-c(\"#ff000050\",\"#0000ff50\")\n  ntsd<-dim(indPPD)[1]\n  ni<-pp*ntsd\n  ind2PPD<-matrix(indPPD[,1:pp,],nrow=ni)\n  ind2Data<-matrix(indData[,1:pp,],nrow=ni)\n  par(mfrow=c(ni-1,ni-1),mai=rep(0,4),omi=c(0.5,0.75,0,0.05))\n\n  for(i in 2:ni){\n\n    for(j in 1:(ni-1)){\n\n      if(j==i|j>i){\n\n        plot(1,1,col='white',axes=F)\n\n      }else{\n\n        #coly=cols[ceiling(posmean(cor(mcmc@rawdat[1:maxn,keep1[i]],mcmc@rawdat[1:maxn,keep2[j]]))*ncols)]\n        xlim<-quantile(c(ind2PPD[i,],ind2Data[i,]),c(0.02,0.98))\n        ylim<-quantile(c(ind2PPD[j,],ind2Data[j,]),c(0.02,0.98))\n        plot(ind2PPD[i,],ind2PPD[j,],pch=19,xlim=xlim,ylim=ylim,cex=0.8,col=cols[1],axes=F)\n        points(ind2Data[i,],ind2Data[j,],pch=19,cex=0.8,col=cols[2])\n\n      }\n\n      if(j==1)mtext(namst[i],2,line=2,cex=0.6,las=2)\n      if(i==ni)mtext(namst[j],1,line=1,cex=0.6,las=2)\n      #if(j==1)mtext(i,2,line=2,cex=0.5,las=2)\n      #if(i==nplotted)mtext(j,1,line=1,cex=0.5,las=2)\n\n    }\n\n  }\n\n}\n\nProbs<-function(indPPD,indData,alpha=0.05){\n\n  np<-dim(indPPD)[2]\n  nsim<-dim(indPPD)[3]\n  #PRB<-array(NA,c(4,np)) # True Negative, False Negative, False Positive, True Positive\n  PRB<-array(NA,c(2,np)) # True Negative, False Negative, False Positive, True Positive\n  mah<-array(NA,c(2,np,nsim))\n\n  for(pp in 1:np){\n\n    ntsd<-dim(indPPD)[1]\n    ni<-pp*ntsd\n\n    ind3PPD<-t(matrix(indPPD[,1:pp,],nrow=ni))\n    ind3Data<-t(matrix(indData[,1:pp,],nrow=ni))\n\n    # NULL = TRUE  (true negatives, false negatives)\n    covr <- cov.mcd(ind3PPD)\n    mahN <- mahalanobis(ind3PPD, center = covr$center, cov = covr$cov, tol = 1e-25)\n    mahA <- mahalanobis(ind3Data, center = covr$center, cov = covr$cov, tol = 1e-25)\n\n    mah[1,pp,]<-mahN\n    mah[2,pp,]<-mahA\n\n    Thres<-quantile(mahN,1-alpha)\n    PRB[1,pp]<-sum(mahN>Thres)/length(mahN)   # False positive\n    PRB[2,pp]<-sum(mahA>Thres)/length(mahA)   # True positive\n\n  }\n\n  list(mah=mah,PRB=PRB)\n\n}\n\n#' Exceptional Circumstances\n#'\n#' @param MSE An object of class MSE\n#' @param hzn Time horizon for posterior data\n#' @param alpha Probability of incorrectly rejecting the null hypothesis of normal data when it is true\n#' @importFrom MVN mardiaTest roystonTest hzTest\n#' @importFrom robustbase covMcd\n#' @return Indicators of MSE misspecification\n#' @author T. Carruthers\n#' @references Carruthers et al. 2018\n#' @export\nEC=function(PPD,Data,res=6,styr=NA,LB=0.9,UB=0.95,plot=T){\n\n  indPPD<-getinds(PPD,styr=styr,res=res)\n  indData<-getinds(Data,styr=styr,res=res)\n\n  if(plot)CC(indPPD,indData,pp=2,res=res)\n\n  out<-Probs(indPPD,indData)\n  np<-dim(indPPD)[2]\n  par(mfrow=c(np,1))\n\n  for(pp in 1:np){\n\n    xlim=quantile(out$mah[,pp,],c(0.01,0.99))\n    densN<-density(out$mah[1,pp,],adj=1,from=0)\n    densN$y<-densN$y/max(densN$y)\n    densA<-density(out$mah[2,pp,],adj=1,from=0)\n    densA$y<-densA$y/max(densA$y)\n\n    plot(densN,xlim=xlim,col='blue',main=\"\")\n    lines(densA,xlim=xlim,col='red')\n\n  }\n\n\n}\n\n\n\n\n# ====================================================================\n",
    "created" : 1516206078055.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4187389981",
    "id" : "97319FEA",
    "lastKnownWriteTime" : 1516232659,
    "last_content_update" : 1516232659360,
    "path" : "C:/GitHub/MSE/R/Ancillary Indicators.R",
    "project_path" : "R/Ancillary Indicators.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}