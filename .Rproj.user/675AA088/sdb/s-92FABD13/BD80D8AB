{
    "collab_server" : "",
    "contents" : "#' Label class union for performance metric objects\n#' \n#' @description Used internally. Nothing to see here!\n#'  \n#' @export\nsetClassUnion(name=\"label.class\", members=c(\"call\", \"character\", \"function\"))\n\n#' Prob class union for performance metric objects\n#' \n#' @description Used internally. Nothing to see here!\n#'  \n#' @export\nsetClassUnion(name=\"prob.class\", members=c(\"matrix\", \"numeric\", \"data.frame\"))\n\n\n# ---- Data Class ----\n\n#' Class \\code{'Data'}\n#' \n#' An object for storing data for analysis using data-limited methods\n#' \n#' \n#' @name Data-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Data', stock)} \n#' @slot Name The name of the Data object. Single value. Character string  \n#' @slot Year Years that corresponding to catch and relative abundance data. Vector nyears long. Positive integer\n#' @slot Cat Total annual catches. Matrix of nsim rows and nyears columns. Non-negative real numbers \n#' @slot Ind Relative abundance index. Matrix of nsim rows and nyears columns. Non-negative real numbers\n#' @slot Rec Recent recruitment strength. Vector of length nsim. Positive real numbers \n#' @slot t The number of years corresponding to AvC and Dt. Single value. Positive integer  \n#' @slot AvC Average catch over time t. Vector nsim long. Positive real numbers  \n#' @slot Dt Depletion over time t SSB(now)/SSB(now-t+1). Vector nsim long. Fraction  \n#' @slot Mort Natural mortality rate. Vector nsim long. Positive real numbers \n#' @slot FMSY_M An assumed ratio of FMSY to M. Vector nsim long. Positive real numbers  \n#' @slot BMSY_B0 The most productive stock size relative to unfished. Vector nsim long. Fraction  \n#' @slot L50 Length at 50 percent maturity. Vector nsim long. Positive real numbers \n#' @slot L95 Length at 95 percent maturity. Vector nsim long. Positive real numbers \n#' @slot ML Mean length time series. Matrix of nsim rows and nyears columns. Non-negative real numbers\n#' @slot Lbar Mean length of catches over Lc. Matrix of nsim rows and nyears columns. Positive real numbers  \n#' @slot Lc Modal length of catches. Matrix of nsim rows and nyears columns. Positive real numbers  \n#' @slot LFC Length at first capture. Matrix of nsim rows and nyears columns. Positive real numbers \n#' @slot LFS Shortest length at full selection. Matrix of nsim rows and nyears columns. Positive real numbers  \n#' @slot CAA Catch at Age data. Array of dimensions nsim x nyears x MaxAge. Non-negative integers\n#' @slot Dep Stock depletion SSB(current)/SSB(unfished). Vector nsim long. Fraction.  \n#' @slot Abun An estimate of absolute current vulnerable abundance. Vector nsim long. Positive real numbers \n#' @slot SpAbun An estimate of absolute current spawning stock abundance. Vector nsim long. Positive real numbers \n#' @slot vbK The von Bertalanffy growth coefficient K. Vector nsim long. Positive real numbers  \n#' @slot vbLinf Maximum length. Vector nsim long. Positive real numbers\n#' @slot vbt0 Theoretical age at length zero. Vector nsim long. Non-positive real numbers\n#' @slot LenCV Coefficient of variation of length-at-age (assumed constant for all age classes). Vector nsim long. Positive real numbers \n#' @slot wla Weight-Length parameter alpha. Vector nsim long. Positive real numbers \n#' @slot wlb Weight-Length parameter beta. Vector nsim long. Positive real numbers  \n#' @slot steep Steepness of stock-recruitment relationship. Vector nsim long. Value in the range of one-fifth to 1 \n#' @slot CV_Cat Coefficient of variation in annual catches. Vector nsim long. Positive real numbers \n#' @slot CV_Dt Coefficient of variation in depletion over time t. Vector nsim long. Positive real numbers  \n#' @slot CV_AvC Coefficient of variation in average catches over time t. Vector nsim long. Positive real numbers\n#' @slot CV_Ind Coefficient of variation in the relative abundance index. Vector nsim long. Positive real numbers \n#' @slot CV_Mort Coefficient of variation in natural mortality rate. Vector nsim long. Positive real numbers \n#' @slot CV_FMSY_M Coefficient of variation in the ratio in FMSY/M. Vector nsim long. Positive real numbers \n#' @slot CV_BMSY_B0 Coefficient of variation in the position of the most productive stock size relative to unfished. Vector nsim long. Positive real numbers \n#' @slot CV_Dep Coefficient of variation in current stock depletion. Vector nsim long. Positive real numbers \n#' @slot CV_Abun Coefficient of variation in estimate of absolute current stock size. Vector nsim long. Positive real numbers \n#' @slot CV_vbK Coefficient of variation in the von Bertalanffy K parameter. Vector nsim long. Positive real numbers \n#' @slot CV_vbLinf Coefficient of variation in maximum length. Vector nsim long. Positive real numbers \n#' @slot CV_vbt0 Coefficient of variation in age at length zero. Vector nsim long. Positive real numbers \n#' @slot CV_L50 Coefficient of variation in length at 50 per cent maturity. Vector nsim long. Positive real numbers \n#' @slot CV_LFC Coefficient of variation in length at first capture. Vector nsim long. Positive real numbers \n#' @slot CV_LFS Coefficient of variation in length at full selection. Vector nsim long. Positive real numbers \n#' @slot CV_wla Coefficient of variation in weight-length parameter a. Vector nsim long. Positive real numbers \n#' @slot CV_wlb Coefficient of variation in weight-length parameter b. Vector nsim long. Positive real numbers \n#' @slot CV_steep Coefficient of variation in steepness. Vector nsim long. Positive real numbers   \n#' @slot sigmaL Assumed observaton error of the length composition data. Vector nsim long. Positive real numbers \n#' @slot MaxAge Maximum age. Vector nsim long. Positive integer \n#' @slot CAL_bins The values delimiting the length bins for the catch-at-length data. Vector. Non-negative real numbers\n#' @slot CAL Catch-at-length data. An array with dimensions nsim x nyears x length(CAL_bins). Non-negative integers \n#' @slot TAC The calculated catch limits (function TAC). An array with dimensions PosMPs x replicate TAC samples x nsim. Positive real numbers  \n#' @slot Sense The results of the sensitivity analysis (function Sense). An array with dimensions PosMPs x sensitivity increments. Positive real numbers  \n#' @slot Units Units of the catch/absolute abundance estimates. Single value. Character string\n#' @slot Ref A reference management level (eg a catch limit). Single value. Positive real number  \n#' @slot Ref_type Type of reference management level (eg 2009 catch limit). Single value. Character string \n#' @slot Log A record of events. Single value. Character string \n#' @slot params A place to store estimated parameters. An object. R list    \n#' @slot PosMPs The methods that can be applied to these data. Vector. Character strings  \n#' @slot MPs The methods that were applied to these data. Vector. Character strings  \n#' @slot OM A table of operating model conditions. R table object of nsim rows. Real numbers  \n#' @slot Obs A table of observation model conditions. R table object of nsim rows. Real numbers \n#' @slot Cref Reference or target catch level (eg MSY). Vector of length nsim. Positive real numbers \n#' @slot Iref Reference or target relative abundance index level (eg BMSY / B0). Vector of length nsim. Positive real numbers \n#' @slot Bref Reference or target biomass level (eg BMSY). Vector of length nsim. Positive real numbers \n#' @slot CV_Cref Log-normal CV for reference or target catch level. Vector of length nsim. Positive real numbers  \n#' @slot CV_Iref Log-normalCV for reference or target relative abundance index level. Vector of length nsim. Positive real numbers\n#' @slot CV_Bref Log-normal CV for reference or target biomass level. Vector of length nsim. Positive real numbers \n#' @slot CV_Rec Log-normal CV for recent recruitment strength. Vector of length nsim. Positive real numbers \n#' @slot MPrec The previous recommendation of a management procedure. Vector of length nsim. Positive real numbers   \n#' @slot MPeff The current level of effort. Vector of length nsim. Positive real numbers  \n#' @slot LHYear The last historical year of the simulation (before projection). Single value. Positive integer  \n#' @slot nareas Number of fishing areas. Vector of length nsim. Non-negative integer \n#' @slot Misc Other information for MPs. An object. R list   \n#' \n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' newdata<-new('Data')\n#' \nsetClass(\"Data\", representation(Name = \"character\", Year = \"vector\", \n                                Cat = \"matrix\", Ind = \"matrix\", Rec = \"matrix\", t = \"vector\",\n                                AvC = \"vector\", Dt = \"vector\", Mort = \"vector\", FMSY_M = \"vector\", \n                                BMSY_B0 = \"vector\", L50 = \"vector\", L95 = \"vector\", \n                                ML = \"array\", Lbar = \"array\", Lc = \"array\",\n                                LFC = \"vector\", LFS = \"vector\", CAA = \"array\", Dep = \"vector\", \n                                Abun = \"vector\", SpAbun=\"vector\", vbK = \"vector\", vbLinf = \"vector\", vbt0 = \"vector\", \n                                LenCV=\"vector\", wla = \"vector\", wlb = \"vector\",  steep = \"vector\", \n                                CV_Cat = \"vector\", CV_Dt = \"vector\", CV_AvC = \"vector\", \n                                CV_Ind = \"vector\", CV_Mort = \"vector\", CV_FMSY_M = \"vector\",\n                                CV_BMSY_B0 = \"vector\", CV_Dep = \"vector\", CV_Abun = \"vector\",\n                                CV_vbK = \"vector\", CV_vbLinf = \"vector\", CV_vbt0 = \"vector\",\n                                CV_L50 = \"vector\", CV_LFC = \"vector\", CV_LFS = \"vector\", \n                                CV_wla = \"vector\", CV_wlb = \"vector\", CV_steep = \"vector\", \n                                sigmaL = \"vector\", MaxAge = \"vector\",\n                                CAL_bins = \"numeric\", CAL = \"array\", \n                                TAC = \"array\", Sense = \"array\",\n                                Units = \"character\", Ref = \"numeric\", Ref_type = \"character\", \n                                Log = \"list\", params = \"list\", PosMPs = \"vector\",\n                                MPs = \"vector\", OM = \"data.frame\", Obs = \"data.frame\", \n                                Cref = \"vector\", Iref = \"vector\",  Bref = \"vector\", \n                                CV_Cref = \"vector\", CV_Iref = \"vector\", CV_Bref = \"vector\", \n                                CV_Rec = \"vector\",  \n                                MPrec = \"vector\", MPeff = \"vector\", LHYear = \"numeric\", \n                                nareas = \"numeric\", Misc = \"list\"))\n\n# initialize Data\nsetMethod(\"initialize\", \"Data\", function(.Object, stock = \"nada\", dec=c(\".\", \",\")) {\n  # .Object }) .Object<-new('Data') run an error check here\n  if (file.exists(stock)) {\n    dec <- match.arg(dec)\n    if (dec == \".\") dat <- read.csv(stock, header = F, colClasses = \"character\")  # read 1st sheet\n    if (dec == \",\") dat <- read.csv2(stock, header = F, colClasses = \"character\")  # read 1st sheet\n    dname <- dat[, 1]\n    dat <- dat[, 2:ncol(dat)]\n    \n    .Object@Name <- dat[match(\"Name\", dname), 1]\n    .Object@Year <- as.numeric(dat[match(\"Year\", dname), dat[match(\"Year\", dname), ] != \"\"])\n    .Object@Cat <- matrix(as.numeric(dat[match(\"Catch\", dname), dat[match(\"Catch\", dname), ] != \"\"]), nrow = 1)\n    .Object@Ind <- matrix(as.numeric(dat[match(\"Abundance index\", dname), 1:length(.Object@Year)]), nrow = 1)\n    .Object@Rec <- matrix(as.numeric(dat[match(\"Recruitment\", dname), 1:length(.Object@Year)]), nrow = 1)\n    .Object@t <- as.numeric(dat[match(\"Duration t\", dname), 1])\n    .Object@AvC <- as.numeric(dat[match(\"Average catch over time t\", dname), 1])\n    .Object@Dt <- as.numeric(dat[match(\"Depletion over time t\", dname), 1])\n    .Object@Mort <- as.numeric(dat[match(\"M\", dname), 1])\n    .Object@FMSY_M <- as.numeric(dat[match(\"FMSY/M\", dname), 1])\n    .Object@BMSY_B0 <- as.numeric(dat[match(\"BMSY/B0\", dname), 1])\n    .Object@L50 <- as.numeric(dat[match(\"Length at 50% maturity\", dname), 1])\n    .Object@L95 <- as.numeric(dat[match(\"Length at 95% maturity\", dname), 1])\n    .Object@ML <- matrix(as.numeric(dat[match(\"Mean length\", dname), 1:length(.Object@Year)]), nrow = 1)\n    .Object@Lbar <- matrix(as.numeric(dat[match(\"Mean length Lc\", dname), 1:length(.Object@Year)]), nrow = 1)\n    .Object@Lc <- matrix(as.numeric(dat[match(\"Modal length\", dname), 1:length(.Object@Year)]), nrow = 1)\n    .Object@LFC <- as.numeric(dat[match(\"Length at first capture\",  dname), 1])\n    .Object@LFS <- as.numeric(dat[match(\"Length at full selection\", dname), 1])\n  \n    CAAy <- grep(\"CAA\", dname)[1:length(grep(\"CAA\", dname))]\n    CAAa <- sum(dat[CAAy[1], ] != \"\")\n    if (!is.na(CAAa)) {\n      .Object@CAA <- array(as.numeric(as.matrix(dat[CAAy, 1:CAAa])),  dim = c(1, length(CAAy), CAAa))\n    }\n    .Object@Dep <- as.numeric(dat[match(\"Current stock depletion\",  dname), 1])\n    .Object@Abun <- as.numeric(dat[match(\"Current stock abundance\",  dname), 1]) \n    .Object@SpAbun <- as.numeric(dat[match(\"Current spawning stock abundance\",  dname), 1])\n    .Object@vbK <- as.numeric(dat[match(\"Von Bertalanffy K parameter\", dname), 1])\n    .Object@vbLinf <- as.numeric(dat[match(\"Von Bertalanffy Linf parameter\", dname), 1])\n    .Object@vbt0 <- as.numeric(dat[match(\"Von Bertalanffy t0 parameter\", dname), 1])\n    .Object@LenCV <- as.numeric(dat[match(\"CV of length-at-age\", dname), 1])\n    .Object@wla <- as.numeric(dat[match(\"Length-weight parameter a\", dname), 1])\n    .Object@wlb <- as.numeric(dat[match(\"Length-weight parameter b\", dname), 1])\n    .Object@steep <- as.numeric(dat[match(\"Steepness\", dname), 1])\n    \n    .Object@CV_Cat <- as.numeric(dat[match(\"CV Catch\", dname), 1])\n    .Object@CV_Dt <- as.numeric(dat[match(\"CV Depletion over time t\", dname), 1])\n    .Object@CV_AvC <- as.numeric(dat[match(\"CV Average catch over time t\", dname), 1])\n    .Object@CV_Ind <- as.numeric(dat[match(\"CV Abundance index\", dname), 1])\n    .Object@CV_Mort <- as.numeric(dat[match(\"CV M\", dname), 1])\n    .Object@CV_FMSY_M <- as.numeric(dat[match(\"CV FMSY/M\", dname),  1])\n    .Object@CV_BMSY_B0 <- as.numeric(dat[match(\"CV BMSY/B0\", dname), 1])\n    .Object@CV_Dep <- as.numeric(dat[match(\"CV current stock depletion\", dname), 1])\n    .Object@CV_Abun <- as.numeric(dat[match(\"CV current stock abundance\", dname), 1])\n    .Object@CV_vbK <- as.numeric(dat[match(\"CV von B. K parameter\", dname), 1])\n    .Object@CV_vbLinf <- as.numeric(dat[match(\"CV von B. Linf parameter\", dname), 1])\n    .Object@CV_vbt0 <- as.numeric(dat[match(\"CV von B. t0 parameter\", dname), 1])\n    .Object@CV_L50 <- as.numeric(dat[match(\"CV Length at 50% maturity\", dname), 1])\n    .Object@CV_LFC <- as.numeric(dat[match(\"CV Length at first capture\", dname), 1])\n    .Object@CV_LFS <- as.numeric(dat[match(\"CV Length at full selection\", dname), 1])\n    .Object@CV_wla <- as.numeric(dat[match(\"CV Length-weight parameter a\", dname), 1])\n    .Object@CV_wlb <- as.numeric(dat[match(\"CV Length-weight parameter b\", dname), 1])\n    .Object@CV_steep <- as.numeric(dat[match(\"CV Steepness\", dname),  1])\n    .Object@sigmaL <- as.numeric(dat[match(\"Sigma length composition\", dname), 1])\n    \n    .Object@MaxAge <- as.numeric(dat[match(\"Maximum age\", dname), 1])\n    \n    if (length(grep(\"CAL\", dname)) > 1) {\n      CAL_bins <- as.numeric(dat[match(\"CAL_bins\", dname), dat[match(\"CAL_bins\", dname), ] != \"\"])\n      nCAL <- length(CAL_bins) - 1\n      .Object@CAL_bins <- CAL_bins\n      CALdat <- grep(\"CAL \", dname)\n      if (length(CALdat) > 0) .Object@CAL <- array(as.numeric(as.matrix(dat[CALdat, 1:nCAL])),dim = c(1, length(CALdat), nCAL))\n    }\n    \n    .Object@Units <- dat[match(\"Units\", dname), 1]\n    .Object@Ref <- as.numeric(dat[match(\"Reference OFL\", dname), 1])\n    .Object@Ref_type <- dat[match(\"Reference OFL type\", dname), 1]\n    \n    .Object@Cref <- as.numeric(dat[match(\"Cref\", dname), 1])\n    .Object@Iref <- as.numeric(dat[match(\"Iref\", dname), 1])\n    .Object@Bref <- as.numeric(dat[match(\"Bref\", dname), 1])\n    \n    .Object@CV_Cref <- as.numeric(dat[match(\"CV Cref\", dname), 1])\n    .Object@CV_Iref <- as.numeric(dat[match(\"CV Iref\", dname), 1])\n    .Object@CV_Bref <- as.numeric(dat[match(\"CV Bref\", dname), 1])\n    .Object@CV_Rec <- as.numeric(dat[match(\"CV Rec\", dname), 1])\n\n    .Object@MPrec <- as.numeric(dat[match(\"MPrec\", dname), 1])\n    .Object@MPeff <- as.numeric(dat[match(\"MPeff\", dname), 1])\n    \n    .Object@LHYear <- as.numeric(dat[match(\"LHYear\", dname), 1])\n    .Object@nareas <- as.numeric(dat[match(\"nareas\", dname), 1])\n\n    .Object@Log[[1]] <- paste(\"Created:\", Sys.time())\n    .Object@params <- new(\"list\")\n    .Object@OM <- data.frame(NA)\n    .Object@Obs <- data.frame(NA)\n    .Object@TAC <- array(NA, dim = c(1, 1, 1))\n    .Object@Sense <- array(NA, dim = c(1, 1, 1))\n    .Object@PosMPs <- NA\n    .Object@MPs <- NA\n    \n  } else {\n    if (stock != \"MSE\") {\n      if (!is.na(stock)) print(\"Couldn't find specified csv file, blank DLM object created\")\n    }\n  }\n  \n  if (is.na(.Object@MPeff) || length(.Object@MPeff)==0) .Object@MPeff <- 1 \n  \n  # Standardise Index if not already \n  .Object@Ind <- .Object@Ind/mean(.Object@Ind, na.rm=TRUE)\n  \n  # Default value\n  if (NAor0(.Object@LenCV)) .Object@LenCV <- 0.1\n  if (NAor0(.Object@CV_Cat)) .Object@CV_Cat <- 0.2\n  if (NAor0(.Object@CV_Dt)) .Object@CV_Dt <- 0.25\n  if (NAor0(.Object@CV_AvC)) .Object@CV_AvC <- 0.2\n  if (NAor0(.Object@CV_Ind)) .Object@CV_Ind <- 0.2\n  if (NAor0(.Object@CV_Mort)) .Object@CV_Mort <- 0.2\n  if (NAor0(.Object@CV_FMSY_M)) .Object@CV_FMSY_M <- 0.2\n  if (NAor0(.Object@CV_BMSY_B0)) .Object@CV_BMSY_B0 <- 0.045\n  if (NAor0(.Object@CV_Cref)) .Object@CV_Cref <- 0.2\n  if (NAor0(.Object@CV_Bref)) .Object@CV_Bref <- 0.2\n  if (NAor0(.Object@CV_Iref)) .Object@CV_Iref <- 0.2\n  if (NAor0(.Object@CV_Rec)) .Object@CV_Rec <- 0.2\n  if (NAor0(.Object@CV_Dep)) .Object@CV_Dep <- 0.25\n  if (NAor0(.Object@CV_Abun)) .Object@CV_Abun <- 0.25\n  if (NAor0(.Object@CV_vbK)) .Object@CV_vbK <- 0.1\n  if (NAor0(.Object@CV_vbLinf)) .Object@CV_vbLinf <- 0.1\n  if (NAor0(.Object@CV_vbt0)) .Object@CV_vbt0 <- 0.1\n  if (NAor0(.Object@CV_L50))  .Object@CV_L50 <- 0.1\n  if (NAor0(.Object@CV_LFC))  .Object@CV_LFC <- 0.2\n  if (NAor0(.Object@CV_LFS))  .Object@CV_LFS <- 0.2\n  if (NAor0(.Object@CV_wla))  .Object@CV_wla <- 0.1\n  if (NAor0(.Object@CV_wlb))  .Object@CV_wlb <- 0.1\n  if (NAor0(.Object@CV_steep)) .Object@CV_steep <- 0.2\n  if (NAor0(.Object@nareas)) .Object@nareas <- 2\n  \n  if (length(.Object@sigmaL) == 0) .Object@sigmaL <- 0.2\n  if (length(.Object@CAA) == 0) .Object@CAA <- array(NA, c(1, 1, 1))\n  if (length(.Object@CAL) == 0) .Object@CAL <- array(NA, c(1, 1, 1))\n  if (length(.Object@CAL_bins) == 0) .Object@CAL_bins <- 1\n  if (length(.Object@TAC) == 0) .Object@TAC <- array(1, c(1, 1))\n  # if (length(.Object@TACbias) == 0) .Object@TACbias <- array(1, c(1, 1))\n  if (length(.Object@Sense) == 0) .Object@Sense <- array(1, c(1, 1))\n  if (length(.Object@ML) == 0)  .Object@ML <- array(NA, c(1, 1))\n  if (length(.Object@Lbar) == 0) .Object@Lbar <- array(NA, c(1, 1))\n  if (length(.Object@Lc) == 0) .Object@Lc <- array(NA, c(1, 1))\n  \n  .Object\n})\n\n\n\n# ---- Fease Class ----\n#' Class \\code{'Fease'}\n#' \n#' An object for storing information about what data are available or might be\n#' available\n#' \n#' @name Fease-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Fease', stock)}\n#'\n#' @slot Name The name of the data feasibility object\n#' @slot Case The names of the data feasibility cases\n#' @slot Catch Total annual catches\n#' @slot Index An index of relative abundance, catch per unit effort data or of fishing mortality rate (effort)\n#' @slot Natural_mortality_rate From Maximum age, Tagging data, early fishery catch composition data\n#' @slot Maturity_at_length From gonadal analysis, growth and natural mortality rate estimates\n#' @slot Growth Paired length and age observations, maximum length and an estimate of natural mortality rate\n#' @slot Length_weight_conversion Paired weight and length observations, equivalent data from a similar species\n#' @slot Fleet_selectivity Length composition of catches with growth curve and natural mortality rate, estimates from a similar fleet type targetting a similar species\n#' @slot Catch_at_length Length composition of catches (length samples)\n#' @slot Catch_at_age Age composition of catches (age samples)\n#' @slot Recruitment_index Spawn survey, estimates from a stock assessment, VPA analysis of catch composition data\n#' @slot Stock_recruitment_relationship Stock assessment, a stock assessment of a similar species\n#' @slot Target_catch An agreed annual catch target, MSY proxy\n#' @slot Target_biomass An agreed absolute biomass target, mean historical biomass estimate\n#' @slot Target_index An agreed catch rate target\n#' @slot Abundance Fishery independent survey, current fishing mortality rate from recent length composition, natural mortality rate, maturity at age, growth and stock recruitment relationship, habitat and relative density extrapolation\n#'\n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' newdata<-new('Fease')\n#' \nsetClass(\"Fease\", representation(Name = \"character\", Case = \"character\", \n                                 Catch = \"numeric\", Index = \"numeric\", Natural_mortality_rate = \"numeric\", \n                                 Maturity_at_length = \"numeric\", Growth = \"numeric\", Length_weight_conversion = \"numeric\", \n                                 Fleet_selectivity = \"numeric\", Catch_at_length = \"numeric\", Catch_at_age = \"numeric\", \n                                 Recruitment_index = \"numeric\", Stock_recruitment_relationship = \"numeric\", \n                                 Target_catch = \"numeric\", Target_biomass = \"numeric\", Target_index = \"numeric\", \n                                 Abundance = \"numeric\"))\n\n# initialize Fease\nsetMethod(\"initialize\", \"Fease\", function(.Object, file = \"nada\", ncases = 1, dec=c(\".\", \",\")) {\n  # run an error check here\n  if (file.exists(file)) {\n    Ncol <- max(unlist(lapply(strsplit(readLines(file), \",\"), length)))\n    dec <- match.arg(dec)\n    if (dec == \".\") dat <- read.csv(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", \n                                                                                   1:Ncol))  # read 1st sheet\n    if (dec == \",\") dat <- read.csv2(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", \n                                                                                                   1:Ncol))  # read 1st sheet\n    nr <- nrow(dat)\n    ncases = ncol(dat) - 1\n    dname <- dat[, 1]\n    if (ncases == 1) dat <- array(dat[, 2:ncol(dat)], dim = c(nr, ncases))\n    if (ncases > 1) dat <- dat[, 2:ncol(dat)]\n    .Object@Name <- dat[match(\"Name\", dname), 1]\n    .Object@Case <- as.character(dat[match(\"Case\", dname), 1:ncases])\n    .Object@Catch <- as.numeric(dat[match(\"Catch\", dname), 1:ncases])\n    .Object@Index <- as.numeric(dat[match(\"Index\", dname), 1:ncases])\n    .Object@Natural_mortality_rate <- as.numeric(dat[match(\"Natural_mortality_rate\",  dname), 1:ncases])\n    .Object@Maturity_at_length <- as.numeric(dat[match(\"Maturity_at_length\",  dname), 1:ncases])\n    .Object@Growth <- as.numeric(dat[match(\"Growth\", dname), 1:ncases])\n    .Object@Length_weight_conversion <- as.numeric(dat[match(\"Length_weight_conversion\", dname), 1:ncases])\n    .Object@Fleet_selectivity <- as.numeric(dat[match(\"Fleet_selectivity\", dname), 1:ncases])\n    .Object@Catch_at_length <- as.numeric(dat[match(\"Catch_at_length\", dname), 1:ncases])\n    .Object@Catch_at_age <- as.numeric(dat[match(\"Catch_at_age\", dname), 1:ncases])\n    .Object@Recruitment_index <- as.numeric(dat[match(\"Recruitment_index\", dname), 1:ncases])\n    .Object@Stock_recruitment_relationship <- as.numeric(dat[match(\"Stock_recruitment_relationship\", dname), 1:ncases])\n    .Object@Target_catch <- as.numeric(dat[match(\"Target_catch\", dname), 1:ncases])\n    .Object@Target_biomass <- as.numeric(dat[match(\"Target_biomass\", dname), 1:ncases])\n    .Object@Target_index <- as.numeric(dat[match(\"Target_index\", dname), 1:ncases])\n    .Object@Abundance <- as.numeric(dat[match(\"Abundance\", dname), 1:ncases])\n  } else {\n    .Object@Name <- \"Blank DLM_Fease\"\n    .Object@Case <- \"Case 1\"\n    .Object@Catch <- 1\n    .Object@Index <- 1\n    .Object@Natural_mortality_rate <- 1\n    .Object@Maturity_at_length <- 1\n    .Object@Growth <- 1\n    .Object@Length_weight_conversion <- 1\n    .Object@Fleet_selectivity <- 1\n    .Object@Catch_at_length <- 1\n    .Object@Catch_at_age <- 1\n    .Object@Recruitment_index <- 1\n    .Object@Stock_recruitment_relationship <- 1\n    .Object@Target_catch <- 1\n    .Object@Target_biomass <- 1\n    .Object@Target_index <- 1\n    .Object@Abundance <- 1\n  }\n  .Object\n  \n})\n\n# ---- Stock Class ----\n#' Class \\code{'Stock'}\n#' \n#' An operating model component that specifies the parameters of the population\n#' dynamics model\n#' \n#' \n#' @name Stock-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Stock')}\n#' @slot Name The name of the Stock object. Single value. Character string \n#' @slot Species Scientific name of the species. Genus and species name. Character string\n#' @slot maxage The maximum age of individuals that is simulated (there is no 'plus group'). Single value. Positive integer\n#' @slot R0 The magnitude of unfished recruitment. Single value. Positive real number\n#' @slot M Natural mortality rate. Uniform distribution lower and upper bounds. Positive real number \n#' @slot M2 (Optional) Natural mortality rate at age. Vector of length 'maxage'. Positive real number\n#' @slot Mexp Exponent of the Lorenzen function assuming an inverse relationship between M and weight. Uniform distribution lower and upper bounds. Real numbers <= 0.\n#' @slot Msd Inter-annual variability in natural mortality rate expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Mgrad Mean temporal trend in natural mortality rate, expressed as a percentage change in M per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot h Steepness of the stock recruit relationship. Uniform distribution lower and upper bounds. Values from 1/5 to 1 \n#' @slot SRrel Type of stock-recruit relationship. Single value, switch (1) Beverton-Holt (2) Ricker. Integer \n#' @slot Perr Process error, the CV of lognormal recruitment deviations. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot AC Autocorrelation in recruitment deviations rec(t)=AC*rec(t-1)+(1-AC)*sigma(t). Uniform distribution lower and upper bounds. Non-negative real numbers \n# #' @slot recgrad Mean temporal trend in log-normal recruitment deviations, expressed as a percentage change per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot Period (Optional) Period for cyclical recruitment pattern in years. Uniform distribution lower and upper bounds. Non-negative real numbers  \n#' @slot Amplitude (Optional) Amplitude in deviation from long-term average recruitment during recruitment cycle (eg a range from 0 to 1 means recruitment decreases or increases by up to 100\\% each cycle). Uniform distribution lower and upper bounds. 0 < Amplitude < 1 \n#' @slot Linf Maximum length. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot K von Bertalanffy growth parameter k. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot t0 von Bertalanffy theoretical age at length zero. Uniform distribution lower and upper bounds. Non-positive real numbers\n#' @slot LenCV Coefficient of variation of length-at-age (assumed constant for all age classes). Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Ksd Inter-annual variability in growth parameter k. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Kgrad Mean temporal trend in growth parameter k, expressed as a percentage change in k per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot Linfsd Inter-annual variability in maximum length. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Linfgrad Mean temporal trend in maximum length, expressed as a percentage change in Linf per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot L50 Length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot L50_95 Length increment from 50 percent to 95 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n# @slot FecB Exponent of the length-fecundity relationship, ie, (relative) fecundity-at-length is proportional to length^FecB (uniform distribution)\n#' @slot D Current level of stock depletion SSB(current)/SSB(unfished). Uniform distribution lower and upper bounds. Fraction\n#' @slot a Length-weight parameter alpha. Single value. Positive real number \n#' @slot b Length-weight parameter beta. Single value. Positive real number\n#' @slot Size_area_1 The size of area 1 relative to area 2. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Frac_area_1 The fraction of the unfished biomass in stock 1. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Prob_staying The probability of inviduals in area 1 remaining in area 1 over the course of one year. Uniform distribution lower and upper bounds. Positive fraction.\n#' @slot Fdisc Fraction of discarded fish that die. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Source A reference to a website or article from which parameters were taken to define the stock object. Single value. Character string. \n\n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' showClass('Stock')\n#' \n# FecB = \"numeric\"\nsetClass(\"Stock\", representation(Name = \"character\", Species=\"character\",\n                                 maxage = \"numeric\", \n                                 R0 = \"numeric\", M = \"numeric\", M2 = \"numeric\", \n                                 Mexp=\"numeric\",  Msd = \"numeric\", Mgrad = \"numeric\",  \n                                 h = \"numeric\", SRrel = \"numeric\", Perr = \"numeric\", AC = \"numeric\",\n                                 Period = \"numeric\", Amplitude = \"numeric\",\n                                 Linf = \"numeric\", K = \"numeric\", t0 = \"numeric\", LenCV=\"numeric\", \n                                 Ksd = \"numeric\", Kgrad = \"numeric\", Linfsd = \"numeric\", Linfgrad = \"numeric\",\n                                 L50 = \"numeric\", L50_95 = \"numeric\", \n                                 D = \"numeric\", \n                                 a = \"numeric\", b = \"numeric\",\n                                 Size_area_1 = \"numeric\", Frac_area_1 = \"numeric\", Prob_staying = \"numeric\", \n                                 Fdisc=\"numeric\", Source = \"character\"))\n\n# initialize Stock\nsetMethod(\"initialize\", \"Stock\", function(.Object, file = NA, dec=c(\".\", \",\")) {\n  \n  if (!is.na(file)) {\n    if (file.exists(file)) {\n      dec <- match.arg(dec)\n      Ncol <- max(unlist(lapply(strsplit(readLines(file), \",\"), length)))\n      if (dec == \".\") dat <- read.csv(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      if (dec == \",\") dat <- read.csv2(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      dname <- dat[, 1]\n      dat <- dat[, 2:ncol(dat)]\n      Ncol <- ncol(dat)\n      .Object@Name <- dat[match(\"Name\", dname), 1]\n      .Object@Species <- dat[match(\"Species\", dname), 1]\n      .Object@maxage <- as.numeric(dat[match(\"maxage\", dname), 1])\n      .Object@R0 <- as.numeric(dat[match(\"R0\", dname), 1])\n      options(warn=-1)\n      temp <- as.numeric(dat[match(\"M\", dname), 1:Ncol])\n      .Object@M <- temp\n      nas <- which(is.na(temp))\n      if (length(nas) > 0) {\n        .Object@M <- temp[1:(nas[1]-1)]\n      }\n      temp <- as.numeric(dat[match(\"M2\", dname), 1:Ncol])\n      .Object@M2 <- temp\n      nas <- which(is.na(temp))\n      if (length(nas) > 0) {\n        .Object@M2 <- temp[1:(nas[1]-1)]\n      }\n      options(warn=1)\n      .Object@Msd <- as.numeric(dat[match(\"Msd\", dname), 1:2])\n      .Object@Mgrad <- as.numeric(dat[match(\"Mgrad\", dname), 1:2])\n      .Object@Mexp <- as.numeric(dat[match(\"Mexp\", dname), 1:2])\n      .Object@Fdisc <- as.numeric(dat[match(\"Fdisc\", dname), 1:2])\n      .Object@h <- as.numeric(dat[match(\"h\", dname), 1:2])\n      .Object@SRrel <- as.numeric(dat[match(\"SRrel\", dname), 1])\n      .Object@Linf <- as.numeric(dat[match(\"Linf\", dname), 1:2])\n      .Object@K <- as.numeric(dat[match(\"K\", dname), 1:2])\n      .Object@t0 <- as.numeric(dat[match(\"t0\", dname), 1:2])\n      .Object@LenCV <- as.numeric(dat[match(\"LenCV\", dname), 1:2])\n      .Object@Ksd <- as.numeric(dat[match(\"Ksd\", dname), 1:2])\n      .Object@Kgrad <- as.numeric(dat[match(\"Kgrad\", dname), 1:2])\n      .Object@Linfsd <- as.numeric(dat[match(\"Linfsd\", dname), 1:2])\n      .Object@Linfgrad <- as.numeric(dat[match(\"Linfgrad\", dname),  1:2])\n      #.Object@recgrad <- as.numeric(dat[match(\"recgrad\", dname), 1:2])\n      .Object@a <- as.numeric(dat[match(\"a\", dname), 1])\n      .Object@b <- as.numeric(dat[match(\"b\", dname), 1])\n      .Object@D <- as.numeric(dat[match(\"D\", dname), 1:2])\n      .Object@Perr <- as.numeric(dat[match(\"Perr\", dname), 1:2])\n      .Object@Period <- as.numeric(dat[match(\"Period\", dname), 1:2])\n      .Object@Amplitude <- as.numeric(dat[match(\"Amplitude\", dname), 1:2])\n      .Object@AC <- as.numeric(dat[match(\"AC\", dname), 1:2])\n      .Object@Size_area_1 <- as.numeric(dat[match(\"Size_area_1\", dname), 1:2])\n      .Object@Frac_area_1 <- as.numeric(dat[match(\"Frac_area_1\", dname), 1:2])\n      .Object@Prob_staying <- as.numeric(dat[match(\"Prob_staying\", dname), 1:2])\n      .Object@L50 <- as.numeric(dat[match(\"L50\", dname), 1:2])\n      .Object@L50_95 <- as.numeric(dat[match(\"L50_95\", dname), 1:2])\n      \n      # .Object@FecB <- as.numeric(dat[match(\"FecB\", dname), 1:2])\n      \n      .Object@Source <- dat[match(\"Source\", dname), 1]\n    } else {\n      message(\"File doesn't exist\")\n    }\n  }\n  if (all(is.na(.Object@LenCV))) .Object@LenCV <- c(0.08, 0.12)\n  # if (all(is.na(.Object@recgrad))) .Object@recgrad <- c(0, 0) # recgrad not currently used\n  if (all(is.na(.Object@Size_area_1))) .Object@Size_area_1 <- .Object@Frac_area_1\n  if (length(.Object@Size_area_1) == 0) .Object@Size_area_1 <- .Object@Frac_area_1\n  \n  .Object\n  \n})\n\n# ---- Fleet Class -----\n#' Class \\code{'Fleet'}\n#' \n#' The component of the operating model that controls fishing dynamics\n#' \n#' \n#' @name Fleet-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Fleet')}\n#'\n#' @slot Name Name of the Fleet object. Single value. Character string. \n#' @slot nyears The number of years for the historical 'spool-up' simulation. Single value. Positive integer \n#' @slot Spat_targ Distribution of fishing in relation to spatial biomass: fishing distribution is proportional to B^Spat_targ. Uniform distribution lower and upper bounds. Real numbers   \n#' @slot EffYears Years representing join-points (vertices) of time-varying effort. Vector. Non-negative real numbers \n#' @slot EffLower Lower bound on relative effort corresponding to EffYears. Vector. Non-negative real numbers\n#' @slot EffUpper Upper bound on relative effort corresponding to EffYears. Vector. Non-negative real numbers \n#' @slot Esd Additional inter-annual variability in fishing mortality rate. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot qinc Average percentage change in fishing efficiency (applicable only to forward projection and input controls). Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot qcv Inter-annual variability in fishing efficiency (applicable only to forward projection and input controls). Uniform distribution lower and upper bounds. Non-negative real numbers\n\n#' @slot L5 Shortest length corresponding to 5 percent vulnerability. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFS Shortest length that is fully vulnerable to fishing. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Vmaxlen The vulnerability of fish at Stock@Linf. Uniform distribution lower and upper bounds. Fraction \n#' @slot isRel Selectivity parameters in units of size-of-maturity (or absolute eg cm). Single value. Boolean.\n#' @slot LR5 Shortest length corresponding ot 5 percent retention. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot LFR Shortest length that is fully retained. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot Rmaxlen The retention of fish at Stock@Linf. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot DR Discard rate - the fraction of caught fish that are discarded. Uniform distribution lower and upper bounds. Fraction\n#' \n#' @slot SelYears (Optional) Years representing join-points (vertices) at which historical selectivity pattern changes. Vector. Positive real numbers\n#' @slot AbsSelYears (Optional) Calendar years corresponding with SelYears (eg 1951, rather than 1), used for plotting only. Vector (of same length as SelYears). Positive real numbers  \n#' @slot L5Lower (Optional) Lower bound of L5 (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot L5Upper (Optional) Upper bound of L5 (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot LFSLower (Optional) Lower bound of LFS (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot LFSUpper (Optional) Upper bound of LFS (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot VmaxLower (Optional) Lower bound of Vmaxlen (use \\code{ChooseSelect} function to set these). Vector. Fraction \n#' @slot VmaxUpper (Optional) Upper bound of Vmaxlen (use \\code{ChooseSelect} function to set these). Vector. Fraction\n#' @slot CurrentYr The current calendar year (final year) of the historical simulations (eg 2011). Single value. Positive integer. \n#' \n#' @slot MPA (Optional) Matrix specifying spatial closures for historical years. Each row should contain year index (e.g 10 for 10th historical year)\n#' followed by fraction of area closed to fishing for each area. i.e. each row represents a change and the number of columns is nareas + 1. \n#' The spatial closures are assumed to remain in place for the future projections unless changed by a MP. \n#' Default (if left blank) is all areas are open to fishing in historical period.\n\n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' showClass('Fleet')\n#' \nsetClass(\"Fleet\", slots = c(Name = \"character\", nyears = \"numeric\", Spat_targ = \"numeric\", \n                            EffYears = \"numeric\", EffLower = \"numeric\", EffUpper = \"numeric\", Esd = \"numeric\", \n                            qinc = \"numeric\", qcv = \"numeric\",   \n                            L5 = \"numeric\", LFS = \"numeric\", Vmaxlen = \"numeric\", isRel = \"character\",\n                            LR5 = \"numeric\", LFR = \"numeric\", Rmaxlen = \"numeric\", DR = \"numeric\",\n                            SelYears = \"numeric\", AbsSelYears = \"numeric\",\n                            L5Lower = \"numeric\", L5Upper = \"numeric\", LFSLower = \"numeric\", LFSUpper = \"numeric\", VmaxLower = \"numeric\", \n                            VmaxUpper = \"numeric\", CurrentYr=\"numeric\", MPA='matrix'))\n\n# initialize Fleet\nsetMethod(\"initialize\", \"Fleet\", function(.Object, file = NA, dec=c(\".\", \",\")) {\n  if (!is.na(file)) {\n    if (file.exists(file)) {\n      dec <- match.arg(dec)\n      Ncol <- max(unlist(lapply(strsplit(readLines(file), \",\"), length)))\n      if (dec == \".\") dat <- read.csv(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      if (dec == \",\") dat <- read.csv2(file, header = F, colClasses = \"character\", col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      dname <- dat[, 1]\n      dat <- dat[, 2:ncol(dat)]\n      \n      .Object@Name <- dat[match(\"Name\", dname), 1]\n      .Object@nyears <- as.numeric(dat[match(\"nyears\", dname), 1])\n      \n      .Object@CurrentYr <- as.numeric(dat[match(\"CurrentYr\", dname), 1])\n      if(is.na(.Object@CurrentYr)).Object@CurrentYr<-.Object@nyears\n      \n      .Object@Spat_targ <- as.numeric(dat[match(\"Spat_targ\", dname),  1:2])\n      if (!is.na(match(\"Esd\", dname))) {\n        .Object@Esd <- as.numeric(dat[match(\"Esd\", dname), 1:2])  \n      } else {\n        .Object@Esd <- as.numeric(dat[match(\"Fsd\", dname), 1:2])  \n      }\n      \n      # .Object@Fgrad<-as.numeric(dat[match('Fgrad',dname),1:2])\n      nEffYears <- ncol(dat[match(\"EffYears\", dname), ])\n      oldw <- getOption(\"warn\")\n      options(warn = -1)\n      chk <- as.numeric(dat[match(\"EffYears\", dname), 1:nEffYears])\n      options(warn = oldw)\n      ind <- which(!is.na(chk))\n      nEffYears <- length(ind)\n      .Object@EffYears <- as.numeric(dat[match(\"EffYears\", dname),  1:nEffYears])\n      .Object@EffLower <- as.numeric(dat[match(\"EffLower\", dname),  1:nEffYears])\n      .Object@EffUpper <- as.numeric(dat[match(\"EffUpper\", dname),  1:nEffYears])\n      .Object@qinc <- as.numeric(dat[match(\"qinc\", dname), 1:2])\n      .Object@qcv <- as.numeric(dat[match(\"qcv\", dname), 1:2])\n      \n      chkName <- match(\"SelYears\", dname)  # Check if vector of selectivity years exists\n      if (is.finite(chkName)) {\n        nSelYears <- ncol(dat[match(\"SelYears\", dname), ])\n        oldw <- getOption(\"warn\")\n        options(warn = -1)\n        chk <- as.numeric(dat[match(\"SelYears\", dname), 1:nSelYears])\n        options(warn = oldw)\n        ind <- which(is.finite(chk))\n        nSelYears <- length(ind)\n        chk <- length(ind)\n        if (is.finite(chk) & chk > 0) {\n          # parameters for selectivity years exists\n          .Object@SelYears <- as.numeric(dat[match(\"SelYears\", dname), 1:nSelYears])\n          .Object@L5Lower <- as.numeric(dat[match(\"L5Lower\", dname), 1:nSelYears])\n          .Object@L5Upper <- as.numeric(dat[match(\"L5Upper\", dname), 1:nSelYears])\n          .Object@LFSLower <- as.numeric(dat[match(\"LFSLower\", dname), 1:nSelYears])\n          .Object@LFSUpper <- as.numeric(dat[match(\"LFSUpper\", dname), 1:nSelYears])\n          .Object@VmaxLower <- as.numeric(dat[match(\"VmaxLower\", dname), 1:nSelYears])\n          .Object@VmaxUpper <- as.numeric(dat[match(\"VmaxUpper\", dname), 1:nSelYears])\n        }\n      }\n      # These are ignored in MSE if L5Lower etc are set\n      .Object@L5 <- as.numeric(dat[match(\"L5\", dname), 1:2])\n      .Object@LFS <- as.numeric(dat[match(\"LFS\", dname), 1:2])\n      .Object@Vmaxlen <- as.numeric(dat[match(\"Vmaxlen\", dname), 1:2])\n      \n      # Retention curve parameters \n      .Object@LR5 <- as.numeric(dat[match(\"LR5\", dname), 1:2])\n      .Object@LFR <- as.numeric(dat[match(\"LFR\", dname), 1:2])\n      .Object@Rmaxlen <- as.numeric(dat[match(\"Rmaxlen\", dname), 1:2])\n      .Object@DR <- as.numeric(dat[match(\"DR\", dname), 1:2])\n      \n      .Object@isRel <- dat[match(\"isRel\", dname), 1]  # Are selecivity parameters relative to maturity?\n      if (NAor0(.Object@isRel)) .Object@isRel <- \"TRUE\"\n      \n      isMPA <- grep('MPA', dname)\n      if (length(isMPA)<1) isMPA <- NA\n      if (!is.na(isMPA)) {\n        MPA <- temp <- data.matrix(dat[isMPA:nrow(dat),])\n        valCols <- !is.na(colSums(MPA))\n        MPA <- MPA[,valCols, drop=FALSE]\n        valRows <- !is.na(rowSums(MPA))\n        MPA <- MPA[valRows, drop=FALSE]\n        MPA <- matrix(MPA, nrow=nrow(temp))\n        .Object@MPA <- MPA\n      }\n      \n    } else {\n      message(\"File doesn't exist\")\n    }\n  }\n  .Object\n})\n\n\n\n\n\n#' ~~ Methods for Function \\code{initialize} ~~\n#' \n#' ~~ Methods for function \\code{initialize} ~~\n#' \n#' \n#' @name initialize-methods\n#' @aliases initialize-methods initialize,Data-method\n#' initialize,Fleet-method initialize,MSE-method initialize,Obs-method\n#' initialize,OM-method initialize,Stock-method initialize\n#' initialize,Fease-method initialize,DLM_general-method\n#' @docType methods\n#' @section Methods: \\describe{\n#' \n#' \\item{list('signature(.Object = \\'DLM\\')')}{ %% ~~describe this method\n#' here~~ }\n#' \n#' \\item{list('signature(.Object = \\'Fleet\\')')}{ %% ~~describe this method\n#' here~~ }\n#' \n#' \\item{list('signature(.Object = \\'MSE\\')')}{ %% ~~describe this method\n#' here~~ }\n#' \n#' \\item{list('signature(.Object = \\'Obs\\')')}{ %% ~~describe this\n#' method here~~ }\n#' \n#' \\item{list('signature(.Object = \\'OM\\')')}{ %% ~~describe this method here~~\n#' }\n#' \n#' \\item{list('signature(.Object = \\'Stock\\')')}{ %% ~~describe this method\n#' here~~ }\n#' \n#' \n#' \\item{list('signature(.Object = \\'Fease\\')')}{ %% ~~describe this method\n#' here~~ } \\item{list('signature(.Object = \\'DLM_general\\')')}{ %% ~~describe\n#' this method here~~ }\n#' \n#' }\n#' @keywords methods ~~ other possible keyword(s) ~~\nNULL\n\n\n# ---- Obs Class ----\n#' Class \\code{'Obs'}\n#' \n#' An operating model component that controls the observation model\n#' \n#' \n#' @name Obs-class\n#' @docType class\n#' @note Its questionable whether the hyperstability/hyperdepletion should be\n#' categorised as an observation model characteristic as it is most often\n#' driven by fleet dynamics (and therefore should be in the fleet object). Oh\n#' well its here and you might want to make it hyperstable beta < 1 or\n#' hyperdeplete beta > 1, only.\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Obs')} \n#' @slot Name The name of the observation model object. Single value. Character string. \n#' @slot Cobs Log-normal catch observation error expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Cbiascv Log-normal coefficient of variation controlling the sampling of bias in catch observations for each simulation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot CAA_nsamp Number of catch-at-age observation per time step. Uniform distribution lower and upper bounds. Positive real numbers   \n#' @slot CAA_ESS Effective sample size (independent age draws) of the multinomial catch-at-age observation error model. Uniform distribution lower and upper bounds. Positive integers\n#' @slot CAL_nsamp Number of catch-at-length observation per time step. Uniform distribution lower and upper bounds. Positive integers\n#' @slot CAL_ESS Effective sample size (independent length draws) of the multinomial catch-at-length observation error model. Uniform distribution lower and upper bounds. Positive integers\n# #' @slot CALcv Log-normal, CV of length-at-age. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Iobs Observation error in the relative abundance indices expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Ibiascv Log-normal coefficient of variation controlling error in observations of relative abundance index. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Btobs Log-normal coefficient of variation controlling error in observations of current stock biomass among years. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Btbiascv Uniform-log bounds for sampling persistent bias in current stock biomass. Uniform-log distribution lower and upper bounds. Positive real numbers \n#' @slot beta A parameter controlling hyperstability/hyperdepletion where values below 1 lead to hyperstability (an index that decreases slower than true abundance) and values above 1 lead to hyperdepletion (an index that decreases more rapidly than true abundance). Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LenMbiascv Log-normal coefficient of variation for sampling persistent bias in length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Mbiascv Log-normal coefficient of variation for sampling persistent bias in observed natural mortality rate. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Kbiascv Log-normal coefficient of variation for sampling persistent bias in observed growth parameter K. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot t0biascv Log-normal coefficient of variation for sampling persistent bias in observed t0. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Linfbiascv Log-normal coefficient of variation for sampling persistent bias in observed maximum length. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFCbiascv Log-normal coefficient of variation for sampling persistent bias in observed length at first capture. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFSbiascv Log-normal coefficient of variation for sampling persistent bias in length-at-full selection. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot FMSYbiascv Log-normal coefficient of variation for sampling persistent bias in FMSY. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot FMSY_Mbiascv Log-normal coefficient of variation for sampling persistent bias in FMSY/M. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot BMSY_B0biascv Log-normal coefficient of variation for sampling persistent bias in BMSY relative to unfished. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Irefbiascv Log-normal coefficient of variation for sampling persistent bias in relative abundance index at BMSY. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Brefbiascv Log-normal coefficient of variation for sampling persistent bias in BMSY. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Crefbiascv Log-normal coefficient of variation for sampling persistent bias in MSY. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Dbiascv Log-normal coefficient of variation for sampling persistent bias in stock depletion. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Dobs Log-normal coefficient of variation controlling error in observations of stock depletion among years. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot hbiascv Log-normal coefficient of variation for sampling persistent bias in steepness. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Recbiascv Log-normal coefficient of variation for sampling persistent bias in recent recruitment strength. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot B0cv Log-normal coefficient of variation for sampling persistent bias in unfished biomass. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot rcv Log-normal coefficient of variation for sampling persistent bias in intrinsic rate of increase. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot Fcurbiascv Log-normal coefficient of variation for sampling persistent bias in current fishing mortality rate. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot Fcurcv Log-normal coefficient of variation controlling error in observations of current fishing mortality rate among years. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot maxagecv Log-normal coefficient of variation for sampling persistent bias in observation of maximum age. Uniform distribution lower and upper bounds. Positive real numbers  \n#'     \n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' showClass('Obs')\n#' \nsetClass(\"Obs\", representation(Name = \"character\", \n                               Cobs = \"numeric\", Cbiascv = \"numeric\", CAA_nsamp = \"numeric\", CAA_ESS = \"numeric\", \n                               CAL_nsamp = \"numeric\", CAL_ESS = \"numeric\", \n                               Iobs = \"numeric\",  Ibiascv = \"numeric\", Btobs = \"numeric\", Btbiascv = \"numeric\", beta = \"numeric\",\n                               LenMbiascv = \"numeric\", Mbiascv = \"numeric\", Kbiascv = \"numeric\",t0biascv = \"numeric\", Linfbiascv = \"numeric\",\n                               LFCbiascv = \"numeric\", LFSbiascv = \"numeric\",\n                               FMSYbiascv = \"numeric\", FMSY_Mbiascv = \"numeric\", BMSY_B0biascv = \"numeric\",\n                               Irefbiascv = \"numeric\", Brefbiascv = \"numeric\", Crefbiascv = \"numeric\", \n                               Dbiascv = \"numeric\", Dobs = \"numeric\",\n                               hbiascv = \"numeric\", Recbiascv = \"numeric\"))\n\n# initialize Obs\nsetMethod(\"initialize\", \"Obs\", function(.Object, file = NA, dec=c(\".\", \",\")) {\n  if (!is.na(file)) {\n    if (file.exists(file)) {\n      dec <- match.arg(dec)\n      Ncol <- max(unlist(lapply(strsplit(readLines(file), \",\"), length)))\n      if (dec ==\".\") dat <- read.csv(file, header = F, colClasses = \"character\", \n                      col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      if (dec ==\",\") dat <- read.csv2(file, header = F, colClasses = \"character\", \n                                     col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      dname <- dat[, 1]\n      dat <- dat[, 2:ncol(dat)]\n      .Object@Name <- dat[match(\"Name\", dname), 1]\n      .Object@LenMbiascv <- as.numeric(dat[match(\"LenMbiascv\", dname), 1])\n      .Object@Cobs <- as.numeric(dat[match(\"Cobs\", dname), 1:2])\n      .Object@Cbiascv <- as.numeric(dat[match(\"Cbiascv\", dname), 1])\n      .Object@CAA_nsamp <- as.numeric(dat[match(\"CAA_nsamp\", dname), 1:2])\n      .Object@CAA_ESS <- as.numeric(dat[match(\"CAA_ESS\", dname), 1:2])\n      .Object@CAL_nsamp <- as.numeric(dat[match(\"CAA_nsamp\", dname), 1:2])\n      .Object@CAL_ESS <- as.numeric(dat[match(\"CAA_ESS\", dname), 1:2])\n      # .Object@CALcv <- as.numeric(dat[match(\"CALcv\", dname), 1:2])\n      .Object@Iobs <- as.numeric(dat[match(\"Iobs\", dname), 1:2])\n      .Object@Mbiascv <- as.numeric(dat[match(\"Mbiascv\", dname), 1])\n      .Object@Kbiascv <- as.numeric(dat[match(\"Kbiascv\", dname), 1])\n      .Object@t0biascv <- as.numeric(dat[match(\"t0biascv\", dname), 1])\n      .Object@Linfbiascv <- as.numeric(dat[match(\"Linfbiascv\", dname), 1])\n      .Object@LFCbiascv <- as.numeric(dat[match(\"LFCbiascv\", dname), 1])\n      .Object@LFSbiascv <- as.numeric(dat[match(\"LFSbiascv\", dname), 1])\n     # .Object@B0cv <- as.numeric(dat[match(\"B0cv\", dname), 1])\n      .Object@FMSYbiascv <- as.numeric(dat[match(\"FMSYbiascv\", dname), 1])\n      .Object@FMSY_Mbiascv <- as.numeric(dat[match(\"FMSY_Mbiascv\", dname), 1])\n      .Object@BMSY_B0biascv <- as.numeric(dat[match(\"BMSY_B0biascv\", dname), 1])\n     # .Object@rcv <- as.numeric(dat[match(\"rcv\", dname), 1])\n      .Object@Dbiascv <- as.numeric(dat[match(\"Dbiascv\", dname), 1])\n      .Object@Dobs <- as.numeric(dat[match(\"Dobs\", dname), 1:2])\n      .Object@Btbiascv <- as.numeric(dat[match(\"Btbiascv\", dname), 1:2])\n      .Object@Btobs <- as.numeric(dat[match(\"Btobs\", dname), 1:2])\n      # .Object@Fcurbiascv <- as.numeric(dat[match(\"Fcurbiascv\", dname), 1])\n      # .Object@Fcurcv <- as.numeric(dat[match(\"Fcurcv\", dname), 1:2])\n      .Object@hbiascv <- as.numeric(dat[match(\"hbiascv\", dname), 1])\n      .Object@Ibiascv <- as.numeric(dat[match(\"Ibiascv\", dname), 1])\n      # .Object@maxagecv <- as.numeric(dat[match(\"maxagecv\", dname), 1])\n      .Object@Recbiascv <- as.numeric(dat[match(\"Recbiascv\", dname), 1:2])\n      .Object@Irefbiascv <- as.numeric(dat[match(\"Irefbiascv\", dname), 1])\n      .Object@Crefbiascv <- as.numeric(dat[match(\"Crefbiascv\", dname), 1])\n      .Object@Brefbiascv <- as.numeric(dat[match(\"Brefbiascv\", dname), 1])\n      .Object@beta <- as.numeric(dat[match(\"beta\", dname), 1:2])\n    } else {\n      message(\"File doesn't exist\")\n    }\n  }\n  .Object\n  \n})\n\n\n\n\n# ---- Imp Class ----\n#' Class \\code{'Imp'}\n#' \n#' An operating model component that specifies the degree of adherence to management recommendations (Implementation error)\n#' \n#' \n#' @name Imp-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Imp')}\n#' @slot Name The name of the Implementation error object. Single value. Character string.  \n#' @slot TACFrac Mean fraction of TAC taken. Uniform distribution lower and upper bounds. Positive real number. \n#' @slot TACSD Log-normal coefficient of variation in the fraction of Total Allowable Catch (TAC) taken. Uniform distribution lower and upper bounds. Non-negative real numbers. \n#' @slot TAEFrac Mean fraction of TAE taken. Uniform distribution lower and upper bounds. Positive real number. \n#' @slot TAESD Log-normal coefficient of variation in the fraction of Total Allowable Effort (TAE) taken. Uniform distribution lower and upper bounds. Non-negative real numbers.\n#' @slot SizeLimFrac The real minimum size that is retained expressed as a fraction of the size. Uniform distribution lower and upper bounds. Positive real number.\n#' @slot SizeLimSD Log-normal coefficient of variation controlling mismatch between a minimum size limit and the real minimum size retained. Uniform distribution lower and upper bounds. Non-negative real numbers.\n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' @examples\n#' \n#' showClass('Imp')\n#' \nsetClass(\"Imp\", representation(Name = \"character\", TACFrac = \"numeric\", TACSD = \"numeric\", \n                               TAEFrac = \"numeric\", TAESD = \"numeric\", \n                               SizeLimFrac=\"numeric\", SizeLimSD = \"numeric\"))\n\n# initialize Imp\nsetMethod(\"initialize\", \"Imp\", function(.Object, file = NA, dec=c(\".\", \",\")) {\n  \n  .Object@Name <- \"Perfect implementation\"\n  .Object@TACSD <- c(0,0)\n  .Object@TACFrac <- c(1,1)\n  .Object@TAESD <- c(0,0)\n  .Object@TAEFrac <-c(1,1)\n  .Object@SizeLimSD <- c(0,0)\n  .Object@SizeLimFrac<-c(1,1)\n  # .Object@Source <-\"DLMtool generated\"\n  \n  if (!is.na(file)) {\n    if (file.exists(file)) {\n      dec <- match.arg(dec)\n      Ncol <- max(unlist(lapply(strsplit(readLines(file), \",\"), length)))\n      if (dec ==\".\") dat <- read.csv(file, header = F, colClasses = \"character\", \n                      col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      if (dec ==\",\") dat <- read.csv2(file, header = F, colClasses = \"character\", \n                                     col.names = paste0(\"V\", 1:Ncol))  # read 1st sheet\n      dname <- dat[, 1]\n      dat <- dat[, 2:ncol(dat)]\n      \n      .Object@Name <- dat[match(\"Name\", dname), 1]\n      .Object@TACSD <- as.numeric(dat[match(\"TACSD\", dname), 1:2])\n      .Object@TACFrac <- as.numeric(dat[match(\"TACFrac\", dname), 1:2])\n      .Object@TAESD <- as.numeric(dat[match(\"TAESD\", dname), 1:2])\n      .Object@TAEFrac <- as.numeric(dat[match(\"TAEFrac\", dname), 1:2])\n      .Object@SizeLimSD <- as.numeric(dat[match(\"SizeLimSD\", dname), 1:2])\n      .Object@SizeLimFrac <- as.numeric(dat[match(\"SizeLimFrac\", dname), 1:2])\n      # .Object@Source <- dat[match(\"Source\", dname), 1]\n      \n    } else {\n      \n      message(\"File doesn't exist\")\n      \n    }\n    \n    \n  }\n  .Object\n  \n})\n\n# ---- OM Class ----\n#' Class \\code{'OM'}\n#' \n#' An object containing all the parameters needed to control the MSE which can\n#' be build from component Stock, Fleet, Obs, and Imp objects. \n#' \n#' Almost all of these inputs are a vector of length 2 which describes the upper and lower\n#' bounds of a uniform distribution from which to sample the parameter.\n#' \n#' \n#' @name OM-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('OM', Stock, Fleet, Obs, Imp)}. \n\n#' @slot Name Name of the operating model\n#' @slot Agency Name of the agency responsible for the management of the fishery. Character string\n#' @slot Region Name of the general geographic region of the fishery. Character string\n#' @slot Sponsor Name of the organization who sponsored the OM. Character string\n#' @slot Latitude Latitude (decimal degrees). Negative values represent the South of the Equator. Numeric. Single value \n#' @slot Longitude Longitude (decimal degrees). Negative values represent the West of the Prime Meridian. Numeric. Single value \n\n#' @slot nsim The number of simulations\n#' @slot proyears The number of projected years\n#' @slot interval The assessment interval - how often would you like to update the management system?\n#' @slot pstar The percentile of the sample of the management recommendation for each method\n#' @slot maxF Maximum instantaneous fishing mortality rate that may be simulated for any given age class\n#' @slot reps Number of samples of the management recommendation for each method. Note that when this is set to 1, the mean value of \n#' the data inputs is used. \n#' @slot cpars A list of custom parameters. Time series are a matrix nsim rows by nyears columns. Single parameters are a vector nsim long\n#' @slot seed A random seed to ensure users can reproduce results exactly\n#' @slot Source A reference to a website or article from which parameters were taken to define the operating model \n\n# Stock slots\n#' @slot Species Scientific name of the species. Genus and species name. Character string\n#' @slot maxage The maximum age of individuals that is simulated (there is no 'plus group'). Single value. Positive integer\n#' @slot R0 The magnitude of unfished recruitment. Single value. Positive real number\n#' @slot M Natural mortality rate. Uniform distribution lower and upper bounds. Positive real number \n#' @slot M2 (Optional) Natural mortality rate at age. Vector of length 'maxage'. Positive real number\n#' @slot Mexp Exponent of the Lorenzen function assuming an inverse relationship between M and weight. Uniform distribution lower and upper bounds. Real numbers <= 0.\n#' @slot Msd Inter-annual variability in natural mortality rate expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Mgrad Mean temporal trend in natural mortality rate, expressed as a percentage change in M per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot h Steepness of the stock recruit relationship. Uniform distribution lower and upper bounds. Values from 1/5 to 1 \n#' @slot SRrel Type of stock-recruit relationship. Single value, switch (1) Beverton-Holt (2) Ricker. Integer \n#' @slot Perr Process error, the CV of lognormal recruitment deviations. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot AC Autocorrelation in recruitment deviations rec(t)=AC*rec(t-1)+(1-AC)*sigma(t). Uniform distribution lower and upper bounds. Non-negative real numbers \n# #' @slot recgrad Mean temporal trend in log-normal recruitment deviations, expressed as a percentage change per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot Period (Optional) Period for cyclical recruitment pattern in years. Uniform distribution lower and upper bounds. Non-negative real numbers  \n#' @slot Amplitude (Optional) Amplitude in deviation from long-term average recruitment during recruitment cycle (eg a range from 0 to 1 means recruitment decreases or increases by up to 100\\% each cycle). Uniform distribution lower and upper bounds. 0 < Amplitude < 1 \n#' @slot Linf Maximum length. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot K von Bertalanffy growth parameter k. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot t0 von Bertalanffy theoretical age at length zero. Uniform distribution lower and upper bounds. Non-positive real numbers\n#' @slot LenCV Coefficient of variation of length-at-age (assumed constant for all age classes). Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Ksd Inter-annual variability in growth parameter k. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Kgrad Mean temporal trend in growth parameter k, expressed as a percentage change in k per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot Linfsd Inter-annual variability in maximum length. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Linfgrad Mean temporal trend in maximum length, expressed as a percentage change in Linf per year. Uniform distribution lower and upper bounds. Real numbers \n#' @slot L50 Length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot L50_95 Length increment from 50 percent to 95 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n# @slot FecB Exponent of the length-fecundity relationship, ie, (relative) fecundity-at-length is proportional to length^FecB (uniform distribution)\n#' @slot D Current level of stock depletion SSB(current)/SSB(unfished). Uniform distribution lower and upper bounds. Fraction\n#' @slot a Length-weight parameter alpha. Single value. Positive real number \n#' @slot b Length-weight parameter beta. Single value. Positive real number\n#' @slot Size_area_1 The size of area 1 relative to area 2. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Frac_area_1 The fraction of the unfished biomass in stock 1. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Prob_staying The probability of inviduals in area 1 remaining in area 1 over the course of one year. Uniform distribution lower and upper bounds. Positive fraction.\n#' @slot Fdisc Fraction of discarded fish that die. Uniform distribution lower and upper bounds. Non-negative real numbers \n\n# Fleet slots\n#' @slot nyears The number of years for the historical 'spool-up' simulation. Single value. Positive integer \n#' @slot Spat_targ Distribution of fishing in relation to spatial biomass: fishing distribution is proportional to B^Spat_targ. Uniform distribution lower and upper bounds. Real numbers   \n#' @slot EffYears Years representing join-points (vertices) of time-varying effort. Vector. Non-negative real numbers \n#' @slot EffLower Lower bound on relative effort corresponding to EffYears. Vector. Non-negative real numbers\n#' @slot EffUpper Upper bound on relative effort corresponding to EffYears. Vector. Non-negative real numbers \n#' @slot Esd Additional inter-annual variability in fishing mortality rate. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot qinc Average percentage change in fishing efficiency (applicable only to forward projection and input controls). Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot qcv Inter-annual variability in fishing efficiency (applicable only to forward projection and input controls). Uniform distribution lower and upper bounds. Non-negative real numbers\n\n#' @slot L5 Shortest length corresponding to 5 percent vulnerability. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFS Shortest length that is fully vulnerable to fishing. Uniform distribution lower and upper bounds. Positive real numbers\n#' @slot Vmaxlen The vulnerability of fish at Stock@Linf. Uniform distribution lower and upper bounds. Fraction \n#' @slot isRel Selectivity parameters in units of size-of-maturity (or absolute eg cm). Single value. Boolean.\n#' @slot LR5 Shortest length corresponding ot 5 percent retention. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot LFR Shortest length that is fully retained. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot Rmaxlen The retention of fish at Stock@Linf. Uniform distribution lower and upper bounds. Non-negative real numbers\n#' @slot DR Discard rate - the fraction of caught fish that are discarded. Uniform distribution lower and upper bounds. Fraction\n#' \n#' @slot SelYears (Optional) Years representing join-points (vertices) at which historical selectivity pattern changes. Vector. Positive real numbers\n#' @slot AbsSelYears (Optional) Calendar years corresponding with SelYears (eg 1951, rather than 1), used for plotting only. Vector (of same length as SelYears). Positive real numbers  \n#' @slot L5Lower (Optional) Lower bound of L5 (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot L5Upper (Optional) Upper bound of L5 (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot LFSLower (Optional) Lower bound of LFS (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot LFSUpper (Optional) Upper bound of LFS (use \\code{ChooseSelect} function to set these). Vector. Non-negative real numbers \n#' @slot VmaxLower (Optional) Lower bound of Vmaxlen (use \\code{ChooseSelect} function to set these). Vector. Fraction \n#' @slot VmaxUpper (Optional) Upper bound of Vmaxlen (use \\code{ChooseSelect} function to set these). Vector. Fraction\n#' @slot CurrentYr The current calendar year (final year) of the historical simulations (eg 2011). Single value. Positive integer. .\n#' @slot MPA (Optional) Matrix specifying spatial closures for historical years. Each row should contain year index (e.g 10 for 10th historical year)\n#' followed by fraction of area closed to fishing for each area. i.e. each row represents a change and the number of columns is nareas + 1. \n#' The spatial closures are assumed to remain in place for the future projections unless changed by a MP. \n#' Default (if left blank) is all areas are open to fishing in historical period.\n\n\n# Obs slots\n#' @slot Cobs Log-normal catch observation error expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot Cbiascv Log-normal coefficient of variation controlling the sampling of bias in catch observations for each simulation. Uniform distribution lower and upper bounds. Non-negative real numbers \n#' @slot CAA_nsamp Number of catch-at-age observation per time step. Uniform distribution lower and upper bounds. Positive real numbers   \n#' @slot CAA_ESS Effective sample size (independent age draws) of the multinomial catch-at-age observation error model. Uniform distribution lower and upper bounds. Positive integers\n#' @slot CAL_nsamp Number of catch-at-length observation per time step. Uniform distribution lower and upper bounds. Positive integers\n#' @slot CAL_ESS Effective sample size (independent length draws) of the multinomial catch-at-length observation error model. Uniform distribution lower and upper bounds. Positive integers\n# #' @slot CALcv Log-normal, CV of length-at-age. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Iobs Observation error in the relative abundance indices expressed as a coefficient of variation. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Ibiascv Log-normal coefficient of variation controlling error in observations of relative abundance index. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Btobs Log-normal coefficient of variation controlling error in observations of current stock biomass among years. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Btbiascv Uniform-log bounds for sampling persistent bias in current stock biomass. Uniform-log distribution lower and upper bounds. Positive real numbers \n#' @slot beta A parameter controlling hyperstability/hyperdepletion where values below 1 lead to hyperstability (an index that decreases slower than true abundance) and values above 1 lead to hyperdepletion (an index that decreases more rapidly than true abundance). Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LenMbiascv Log-normal coefficient of variation for sampling persistent bias in length at 50 percent maturity. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Mbiascv Log-normal coefficient of variation for sampling persistent bias in observed natural mortality rate. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Kbiascv Log-normal coefficient of variation for sampling persistent bias in observed growth parameter K. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot t0biascv Log-normal coefficient of variation for sampling persistent bias in observed t0. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Linfbiascv Log-normal coefficient of variation for sampling persistent bias in observed maximum length. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFCbiascv Log-normal coefficient of variation for sampling persistent bias in observed length at first capture. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot LFSbiascv Log-normal coefficient of variation for sampling persistent bias in length-at-full selection. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot FMSYbiascv Log-normal coefficient of variation for sampling persistent bias in FMSY. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot FMSY_Mbiascv Log-normal coefficient of variation for sampling persistent bias in FMSY/M. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot BMSY_B0biascv Log-normal coefficient of variation for sampling persistent bias in BMSY relative to unfished. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Irefbiascv Log-normal coefficient of variation for sampling persistent bias in relative abundance index at BMSY. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot Brefbiascv Log-normal coefficient of variation for sampling persistent bias in BMSY. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Crefbiascv Log-normal coefficient of variation for sampling persistent bias in MSY. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Dbiascv Log-normal coefficient of variation for sampling persistent bias in stock depletion. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Dobs Log-normal coefficient of variation controlling error in observations of stock depletion among years. Uniform distribution lower and upper bounds. Positive real numbers \n#' @slot hbiascv Log-normal coefficient of variation for sampling persistent bias in steepness. Uniform distribution lower and upper bounds. Positive real numbers  \n#' @slot Recbiascv Log-normal coefficient of variation for sampling persistent bias in recent recruitment strength. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot B0cv Log-normal coefficient of variation for sampling persistent bias in unfished biomass. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot rcv Log-normal coefficient of variation for sampling persistent bias in intrinsic rate of increase. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot Fcurbiascv Log-normal coefficient of variation for sampling persistent bias in current fishing mortality rate. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot Fcurcv Log-normal coefficient of variation controlling error in observations of current fishing mortality rate among years. Uniform distribution lower and upper bounds. Positive real numbers \n# #' @slot maxagecv Log-normal coefficient of variation for sampling persistent bias in observation of maximum age. Uniform distribution lower and upper bounds. Positive real numbers  \n\n# Imp slots\n#' @slot TACFrac Mean fraction of TAC taken. Uniform distribution lower and upper bounds. Positive real number. \n#' @slot TACSD Log-normal coefficient of variation in the fraction of Total Allowable Catch (TAC) taken. Uniform distribution lower and upper bounds. Non-negative real numbers. \n#' @slot TAEFrac Mean fraction of TAE taken. Uniform distribution lower and upper bounds. Positive real number. \n#' @slot TAESD Log-normal coefficient of variation in the fraction of Total Allowable Effort (TAE) taken. Uniform distribution lower and upper bounds. Non-negative real numbers.\n#' @slot SizeLimFrac The real minimum size that is retained expressed as a fraction of the size. Uniform distribution lower and upper bounds. Positive real number.\n#' @slot SizeLimSD Log-normal coefficient of variation controlling mismatch between a minimum size limit and the real minimum size retained. Uniform distribution lower and upper bounds. Non-negative real numbers.\n\n#' @author T. Carruthers and A. Hordyk\n#' @keywords classes\n#' \nsetClass(\"OM\", representation(Name = \"character\", Agency=\"character\",\n                              Region=\"character\", Sponsor=\"character\",\n                              Latitude=\"numeric\", Longitude=\"numeric\",\n                              nsim=\"numeric\", proyears=\"numeric\", \n                              interval='numeric', pstar='numeric', maxF='numeric', reps='numeric',\n                              cpars=\"list\",seed=\"numeric\", Source=\"character\"), contains=c(\"Stock\", \"Fleet\", \"Obs\", \"Imp\"))\n\n\n# initialize OM\nsetMethod(\"initialize\", \"OM\", function(.Object, Stock=NULL, Fleet=DLMtool::Generic_Fleet, \n                                       Obs=DLMtool::Generic_Obs, Imp=DLMtool::Perfect_Imp, \n                                       interval=4, pstar=0.5, maxF=0.8, reps=1, nsim=48, proyears=50) {\n  if (is.null(Stock)) {\n    message(\"No Stock object found. Returning a blank OM object\") \n    return(makePerf(.Object))\n  }\n  \n  if (class(Stock) != \"Stock\") \n    print(paste(\"Could not build operating model:\", deparse(substitute(Stock)), \"not of class Stock\"))\n  if (class(Fleet) != \"Fleet\") \n    print(paste(\"Could not build operating model:\", deparse(substitute(Fleet)), \"not of class Fleet\"))\n  if (class(Obs) != \"Obs\") \n    print(paste(\"Could not build operating model:\", deparse(substitute(Obs)), \"not of class Obs\"))\n  if (class(Imp) != \"Imp\") \n    print(paste(\"Could not build operating model:\", deparse(substitute(Imp)), \"not of class Imp\"))\n  if (class(Stock) != \"Stock\" | class(Fleet) != \"Fleet\" | class(Obs) != \"Obs\"  | class(Imp) != \"Imp\") stop()\n  .Object@Name <- paste(\"Stock:\", Stock@Name, \"  Fleet:\", Fleet@Name, \"  Obs model:\", \n                        Obs@Name, \"  Imp model:\", Imp@Name, sep = \"\")\n  \n  # Now copy the values for stock, fleet and observation slots to same\n  # slots in the Sim object\n  Sslots <- slotNames(Stock)\n  for (i in 2:length(Sslots)) {\n    tt <- .hasSlot(Stock, Sslots[i])  # For back-compatibility\n    if (tt) slot(.Object, Sslots[i]) <- slot(Stock, Sslots[i])\n  }\n  Fslots <- slotNames(Fleet)\n  for (i in 2:length(Fslots)) {\n    tt <- .hasSlot(Fleet, Fslots[i])\n    if (tt) slot(.Object, Fslots[i]) <- slot(Fleet, Fslots[i])\n  }\n  Oslots <- slotNames(Obs)\n  for (i in 2:length(Oslots)) {\n    tt <- .hasSlot(Obs, Oslots[i])\n    if (tt) slot(.Object, Oslots[i]) <- slot(Obs, Oslots[i])\n  }\n  Islots <- slotNames(Imp)\n  for (i in 2:length(Islots)) {\n    tt <- .hasSlot(Imp, Islots[i])\n    if (tt) slot(.Object, Islots[i]) <- slot(Imp, Islots[i])\n  }\n  \n  # \n  # source <- paste(\"Stock:\", Stock@Source, \"Fleet:\", Fleet@Source, \"Obs:\", Obs@Source, \"Imp:\",Imp@Source)\n  slot(.Object, \"Source\") <- Stock@Source\n  \n  # Default MSE parameters\n  if (.hasSlot(.Object, \"nsim\")) .Object@nsim <- nsim\n  if (.hasSlot(.Object, \"proyears\")) .Object@proyears <- proyears\n  \n  # interval, pstar, maxF, reps\n  if (.hasSlot(.Object, \"interval\")) .Object@interval <- interval\n  if (.hasSlot(.Object, \"pstar\")) .Object@pstar <- pstar\n  if (.hasSlot(.Object, \"maxF\")) .Object@maxF <- maxF\n  if (.hasSlot(.Object, \"reps\")) .Object@reps <- reps\n  \n  if(length(.Object@Mexp) < 2) .Object@Mexp <- c(0,0)\n  if(length(.Object@LenCV) < 2) .Object@LenCV <- c(0.08,0.15)\n  if(length(.Object@CurrentYr)==0).Object@CurrentYr=.Object@nyears\n  \n  # if(length(.Object@FecB) < 2) .Object@FecB <- c(3,3)\n  # if(all(is.na(.Object@FecB))) .Object@FecB <- c(3,3)  \n  if(all(is.na(.Object@Mexp))) .Object@Mexp <- c(0,0)\n  if(all(is.na(.Object@LenCV))) .Object@LenCV <- c(0.08,0.15)\n  if(all(is.na(.Object@CurrentYr))) .Object@CurrentYr=.Object@nyears\n  \n  if(length(.Object@LR5) < 2) .Object@LR5 <- c(0,0)\n  if(length(.Object@LFR) < 2) .Object@LFR <- c(0,0)\n  if(length(.Object@Rmaxlen) < 2) .Object@Rmaxlen <- c(1,1)\n  if(length(.Object@Fdisc) < 2) .Object@Fdisc <- c(0,0)\n  \n  if(all(is.na(.Object@LR5))) .Object@LR5 <- c(0,0)  \n  if(all(is.na(.Object@LFR))) .Object@LFR <- c(0,0)  \n  if(all(is.na(.Object@Rmaxlen))) .Object@Rmaxlen <- c(1,1)\n  if(all(is.na(.Object@Fdisc))) .Object@Fdisc <- c(0,0)  \n  \n  if (.hasSlot(.Object, \"Size_area_1\")) {\n    if (length(.Object@Size_area_1)==0) .Object@Size_area_1 <- .Object@Frac_area_1\n    if (all(is.na(.Object@Size_area_1))) .Object@Size_area_1 <- .Object@Frac_area_1\n  } \n  \n  .Object@seed=1\n  .Object\n})\n\n\n# ---- MSE Class ----\n#' Class \\code{'MSE'}\n#' \n#' A Management Strategy Evaluation object that contains information about\n#' simulation conditions and performance of data-limited methods\n#' \n#' \n#' @name MSE-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('MSE', Name, nyears, proyears, nMPs, MPs, nsim, OMtable, Obs,\n#' B_BMSYa, F_FMSYa, Ba, FMa, Ca, OFLa, Effort, PAA, CAA, CAL, CALbins)} \n#'\n#' @slot Name Name of the MSE object. Single value. Character string\n#' @slot nyears The number of years for the historical simulation. Single value. Positive integer\n#' @slot proyears The number of years for the projections - closed loop simulations. Single value. Positive integer\n#' @slot nMPs Number of management procedures simulation tested. Single value. Positive integer. \n#' @slot MPs The names of the MPs that were tested. Vector of length nMPs. Character strings. \n#' @slot nsim Number of simulations. Single value. Positive integer\n#' @slot OM A table of sampled parameter of the operating model. Table object of nsim rows. Real numbers\\cr\n#'   \\itemize{\n#'   \\item RefY: reference yield, the highest long-term yield (mean over last five years of projection) obtained from a fixed F strategy. This is a useful reference point for framing performance of MPs because it standardizes for starting point and future productivity. \n#'   \\item M: instantaneous natural mortality rate\n#'   \\item Depletion: stock depletion (biomass / unfished biomass) in the final historical year (prior to projection)\n#'   \\item A: abundance (biomass) updated in each management update of projection\n#'   \\item BMSY_B0: most productive stock size relative to unfished\n#'   \\item FMSY_M: fishing mortality rate divided by natural mortality rate\n#'   \\item Mgrad: mean average percentage gradient in natural mortality rate (percentage per time step)\n#'   \\item Msd: interannual variability in natural mortality rate (lognormal CV)\n#'   \\item procsd: process error - CV in log-normal recruitment deviations\n#'   \\item Esd: interannual variability in historical effort (fishing mortality rate)\n#'   \\item dFfinal: gradient in fishing mortality rate over final five years of the historical simulation\n#'   \\item MSY: Maximum Sustainable Yield\n#'   \\item qinc: mean percentage increase in fishing efficiency (catchability) in projected years (input controls only)\n#'   \\item qcv: interannual variability in future fishing efficiency (catchability) in projected years (input controls only)\n# #'   \\item CALcv: variability in lengths at age around the growth curve (normal CV)\n#'   \\item FMSY: Fishing mortality rate at Maximum Sustainable Yield\n#'   \\item Linf: maximum length (von Bertalanffy Linf parameter)\n#'   \\item K: maximum growth rate (von Bertalanffy K parameter)\n#'   \\item t0: theoretical length at age zero (von Bertalanffy t0 parameter)\n#'   \\item hs: steepness of the stock recruitment relationship (the fraction of unfished recruitment at a fifth of unfished stock levels)\n#'   \\item Linfgrad: mean gradient in maximum length (per cent per time step)\n#'   \\item Kgrad: mean gradient in maximum growth rate (per cent per time step)\n#'   \\item Linfsd: interannual variability in maximum length (log normal CV)\n# #'   \\item recgrad: gradient in recruitment strength (age 1 population numbers) over last 10 years of historical simulations\n#'   \\item Ksd: interannual variability in maximum growth rate (log normal CV)\n#'   \\item ageM: age at 50 per cent maturity\n#'   \\item LFS: length at full selection (the shortest length class where fishery selectivity is 100 per cent)\n#'   \\item age05: the age at 5 percent selectivity (ascending limb of selectivity curve)\n#'   \\item Vmaxage: the selectivity of the oldest age class (controls dome shape of selectivity curve)\n#'   \\item LFC: length at first capture, the smallest length that can be caught by the gear\n#'   \\item OFLreal: the true simulated Over Fishing Limit (FMSY x biomass) updated in each management update of the projection\n#'   \\item Spat_targ: spatial targetting parameter, fishing mortality rate across areas is proportional to vulnerable biomass raised to the power of this number. \n#'   \\item Size_area_1: The size of area 1 relative to area 2\n#'   \\item Frac_area_1: the fraction of unfished biomass inhabiting area 1 (can be seen as fraction of habitat in area 1 or relative size of area 1)\n#'   \\item Prob_staying: the probability that individuals in area 1 remain there between time-steps\n#'   \\item AC: autocorrelation in recruitment\n#'  }\n#' @slot Obs A table of sampled parameters of the observation model. Table of nsim rows. Real numbers\\cr\n#'   \\itemize{\n#'   \\item Cbias: bias in observed catches\n#'   \\item Csd: observation error in observed catches (lognormal CV)\n#'   \\item CAA_nsamp: the number of catch-at-age observations per time step\n#'   \\item CAA_ESS: the effective sample size of multinomial catch-at-age observation model (number of independent draws)\n#'   \\item CAL_nsamp: the number of catch-at-length observations per time step\n#'   \\item CAL_ESS: the effective sample size of multinomial catch-at-length observation model (number of independent draws)\n#'   \\item Isd: observation error in relative abundance index (lognormal CV)\n#'   \\item Dbias: bias in observed stock depletion (also applies to depletion Dt for DCAC)\n#'   \\item Mbias: bias in observed natural mortality rate\n#'   \\item FMSY_Mbias: bias in ratio of FMSY to natural mortality rate\n#'   \\item BMSY_B0bias: bias in ratio of most productive stock size relative to unfished\n#'   \\item AMbias: bias in age at 50 per cent maturity\n#'   \\item LFCbias: bias in length at first capture\n#'   \\item LFSbias: bias in length at full selection\n#'   \\item Abias: bias in observed current absolute stock biomass\n#'   \\item Kbias: bias in maximum growth rate (von Bertalanffy K parameter)\n#'   \\item t0bias: bias in theoretical length at age zero (von Bertalanffy t0 parameter)\n#'   \\item Linfbias: bias in maximum length (von Bertalanffy Linf parameter)\n#'   \\item hbias: bias in observed steepness of the stock recruitment relationship\n#'   \\item Irefbias: bias in abundance index corresponding to BMSY stock levels\n#'   \\item Crefbias: bias in MSY prediction (target or reference catch)\n#'   \\item Brefbias: bias in BMSY stock levels (target or reference biomass levels)}\n#' @slot B_BMSY Simulated biomass relative to BMSY over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers \n#' @slot F_FMSY Simulated fishing mortality rate relative to FMSY over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot B Simulated stock biomass over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers \n#' @slot SSB Simulated spawning stock biomass over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot VB Simulated vulnerable biomass over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot FM Simulated fishing mortality rate over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot C Simulated catches (taken) over the projection. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot TAC Simulated Total Allowable Catch (prescribed) over the projection (this is NA for input controls). An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers \n#' @slot SSB_hist Simulated historical spawning stock biomass. An array with dimensions: nsim, nages, nMPs, proyears. Non-negative real numbers\n#' @slot CB_hist Simulated historical catches in weight. An array with dimensions: nsim, nages, nMPs, proyears. Non-negative real numbers\n#' @slot FM_hist Simulated historical fishing mortality rate. An array with dimensions: nsim, nages, nMPs, proyears. Non-negative real numbers\n#' @slot Effort Simulated relative fishing effort in the projection years. An array with dimensions: nsim, nMPs, proyears. Non-negative real numbers\n#' @slot PAA Population at age in last projection year. An array with dimensions: nsim, nMPs, nages. Non-negative real numbers\n#' @slot CAA Catch at age in last projection year. An array with dimensions: nsim, nMPs, nages. Non-negative real numbers\n#' @slot CAL Catch at length in last projection year. An array with dimensions: nsim, nMPs, nCALbins. Non-negative real numbers\n#' @slot CALbins Mid-points of the catch-at-length bins. Vector of length nCALbins. Positive real numbers. \n#' @slot Misc Miscellanenous output such as posterior predictive data\n#'\n#' @author T. Carruthers\n#' @keywords classes\nsetClass(\"MSE\", representation(Name = \"character\", nyears = \"numeric\", \n                               proyears = \"numeric\", nMPs = \"numeric\", MPs = \"character\", nsim = \"numeric\", \n                               OM = \"data.frame\", Obs = \"data.frame\", B_BMSY = \"array\", F_FMSY = \"array\", \n                               B = \"array\", SSB=\"array\", VB=\"array\", FM = \"array\", C = \"array\", \n                               TAC = \"array\", SSB_hist = \"array\", \n                               CB_hist = \"array\", FM_hist = \"array\", Effort = \"array\", PAA= \"array\", CAA= \"array\", \n                               CAL= \"array\", CALbins=\"numeric\", Misc=\"list\"))\n\n\nsetMethod(\"initialize\", \"MSE\", function(.Object, Name, nyears, proyears, \n                                        nMPs, MPs, nsim, OM, Obs, B_BMSY, F_FMSY, B, SSB, VB, FM, C, TAC, \n                                        SSB_hist, CB_hist, FM_hist, Effort = array(), PAA,  CAA, CAL, CALbins, Misc) {\n  .Object@Name <- Name\n  .Object@nyears <- nyears\n  .Object@proyears <- proyears\n  .Object@nMPs <- nMPs\n  .Object@MPs <- MPs\n  .Object@nsim <- nsim\n  .Object@OM <- OM\n  .Object@Obs <- Obs\n  .Object@B_BMSY <- B_BMSY\n  .Object@F_FMSY <- F_FMSY\n  .Object@B <- B\n  .Object@SSB <- SSB\n  .Object@VB <- VB\n  .Object@FM <- FM\n  .Object@C <- C  \n  .Object@TAC <- TAC\n  .Object@SSB_hist <- SSB_hist\n  .Object@CB_hist <- CB_hist\n  .Object@FM_hist <- FM_hist\n  .Object@Effort <- Effort\n  .Object@PAA <- PAA\n  .Object@CAA <- CAA\n  .Object@CAL <- CAL\n  .Object@CALbins <- CALbins\n  .Object@Misc <- Misc\n  \n  .Object\n})\n\n# setMethod(\"initialize\", \"MSE\", function(.Object, Name, nyears, proyears, \n# nMPs, MPs, nsim, OMtable, Obs, B_BMSYa, F_FMSYa, Ba, FMa, Ca, TACa, \n# SSB_hist, CB_hist, FM_hist, Effort = array()) {\n# .Object@Name <- Name\n# .Object@nyears <- nyears\n# .Object@proyears <- proyears\n# .Object@nMPs <- nMPs\n# .Object@MPs <- MPs\n# .Object@nsim <- nsim\n# .Object@OM <- OMtable\n# .Object@Obs <- Obs\n# .Object@B_BMSY <- B_BMSYa\n# .Object@F_FMSY <- F_FMSYa\n# .Object@B <- Ba\n# .Object@FM <- FMa\n# .Object@C <- Ca\n# .Object@TAC <- TACa\n# .Object@SSB_hist <- SSB_hist\n# .Object@CB_hist <- CB_hist\n# .Object@FM_hist <- FM_hist\n# .Object@Effort <- Effort\n# .Object\n# })\n\n\n#' Example data object\n#' \n#' Example data object with a number of output control MPs run on it, and\n#' includes resulting distributions of TACs\n#' \n#' \n#' @name ourReefFish\n#' @docType data\n#' @usage data('ourReefFish')\n#' @keywords datasets\n#' @examples\n#' \\dontrun{ \n#' data(ourReefFish)\n#' str(ourReefFish)  \n#' plot(ourReefFish) \n#' }\n#'\nNULL\n\n\n# ---- PMobj Class ----\n\n#' An object for storing data for analysis using data-limited methods\n#' \n#' Used interally\n#' \n#' @name PMobj-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('PMobj')} \n#' @slot name Name of the Performance Metric. Character \n#' @slot caption A caption to be used in plots. Character, call, or function.\n#' @slot Stat Statistic of interest for the PM. Dimensions: nsim, nMP, yrs. Array \n#' @slot Prob Probability (mean over years) Dimensions: nsim by MP.  Matrix, numeric or data.frame  \n#' @slot Mean Mean probability (mean over years and simulations). Numeric. Length nMPs \n#' @slot MPs Name of MPs. Single value. Character string  \n#' @author  A. Hordyk\n#' @importFrom methods show\n#' @keywords classes\n\nsetClass(\"PMobj\", representation(name = \"character\",  caption='label.class', \n                                 Stat='array', Prob='prob.class', Mean='numeric',\n                                 MPs=\"character\"))\n\n\n#' Calculate Probabilty\n#' \n#' @param PM A PM method \n#' @param MSEobj An object of class MSE\n#'\n#' @export\n#'\ncalcProb <- function(PM,  MSEobj) {\n  mar <- ifelse(MSEobj@nMPs>1, 2, 1) # set margins for apply\n  mar <- 1:mar\n  apply(PM, mar, mean)\n}\n\n#' Calculate Mean Probabilty\n#' \n#' @param Prob Prob slot from an object of class PMobj \n#' @param MSEobj An object of class MSE\n#'\n#' @export\n#'\ncalcMean <- function(Prob, MSEobj) {\n  if (class(Prob) == 'matrix') return( apply(Prob , 2, mean))\n  if (class(Prob) == 'numeric') return(mean(Prob))\n}\n\nshow <- function(object) methods::show(object)\n\n\n#' Show the output of a PM\n#'\n#' @param object object of class MSE\n#' @rdname show-MSE\n#' @export\nsetMethod(\"show\", signature = (object=\"PMobj\"), function(object) {\n  cat(object@name)\n  cat(\"\\n\", object@caption)\n  cat(\"\\n\")\n  \n  nMP <- length(object@MPs)\n  if (nMP > 1) nsim <- dim(object@Prob)[1]\n  if (nMP == 1) nsim <- length(object@Prob)\n  \n  nprint <- min(nsim, 10)\n  if (nMP > 1) df <- data.frame(object@Prob[1:nprint,])\n  if (nMP == 1) df <- data.frame(object@Prob[1:nprint])\n  if (nMP > 1) lst <- object@Prob[nprint+1,]\n  if (nMP == 1) lst <- object@Prob[nprint+1]\n  df <- signif(df,2)\n  lst <- signif(lst,2)\n  colnames(df) <- object@MPs\n  names(lst) <- object@MPs\n  if (nsim > (nprint+1)) {\n    df <- rbind(df,\n                rep(\".\", nMP),\n                rep(\".\", nMP),\n                rep(\".\", nMP),\n                lst)\n    rownames(df) <- c(1:(nprint+3), nsim)\n  }\n  print(df)\n  \n  cat(\"\\nMean\\n\")\n  print(signif(object@Mean,2))\n})\n\n\n#' Summary of MSE object\n#'\n#' @param object object of class MSE\n#' @param ... a list of names of PM methods\n#' @param silent Should summary be printed to console? Logical.\n#' @rdname summary-MSE\n#' @export\nsetMethod('summary', signature=\"MSE\", function(object, ..., silent=FALSE) {\n  PMlist <- unlist(list(...))\n  \n  if(length(PMlist) == 0) PMlist <- avail(\"PM\")\n  if (class(PMlist) != 'character') stop(\"Must provide names of PM methods\")\n  # check\n  for (X in seq_along(PMlist)) \n    if (!PMlist[X] %in% avail(\"PM\")) stop(PMlist[X], \" is not a valid PM method\")\n  \n  if (!silent) message(\"Calculating Performance Metrics\")\n  storeMean <- vector('list', length(PMlist))\n  storeName <- vector('list', length(PMlist))\n  storeHeading <- vector('list', length(PMlist))\n  storeMP <- vector('list', length(PMlist))\n  for (X in 1:length(PMlist)) {\n    runPM <- eval(call(PMlist[[X]],object))\n    storeMean[[X]] <- runPM@Mean\n    storeName[[X]] <- runPM@name\n    # storeHeading[[X]] <- runPM@call\n    storeMP[[X]] <- runPM@MPs\n  }\n  \n  df <- data.frame('MP'=storeMP[[1]], signif(do.call('cbind', storeMean),2))\n  # heading <- do.call('rbind', storeHeading)\n  colnames(df)[2:(length(PMlist)+1)] <- PMlist #caps # gsub(\" \", \"\", caps)\n  if (!silent) {\n    print(data.frame('Performance Metrics' = do.call('rbind', storeName)))\n    cat(\"\\n\")\n    cat(\"\\nProbability:\\n\")\n    print(df)  \n  }\n  \n  invisible(df)\n  \n})\n\n\n# # ---- Plot Data Object -----\n# #' Plot Data object\n# #'\n# #' @rdname plot-Data \n# #' @param x object of class Data\n# #' @param upq Upper quantile of TACs for max ylim\n# #' @param lwq Lower quantile of TACs for min ylim\n# #' @param outline Logical. Include outliers in plot?\n# #' @param ...  Optional additional arguments passed to \\code{boxplot}\n# #' @export\n# setMethod(\"plot\",\n#           signature(x = \"Data\"),\n#           function(x, upq=0.9, lwq=0.1, outline = FALSE, ...){\n#             \n#             old_par <- par(no.readonly = TRUE)\n#             on.exit(par(list = old_par), add = TRUE)\n#             boxplot.Data(x, upq, lwq, outline, ...)\n#           })\n#             # Data<-x\n            # if (class(Data) != \"Data\") stop(\"Must supply object of class Data\")\n            # if (all(is.na(Data@TAC))) stop(\"No TAC data found\")\n            # cols<-rep(c('black','red','green','blue','orange','brown','purple','dark grey','violet','dark red','pink','dark blue','grey'),4)\n            # ltys<-rep(1:4,each=13)\n            # \n            # if(is.na(funcs[1]))funcs<-Data@MPs\n            # \n            # nMPs<-length(funcs)\n            # nplots<-ceiling(nMPs/maxlines)\n            # maxl<-ceiling(nMPs/nplots)\n            # mbyp <- split(1:nMPs, ceiling(1:nMPs/maxl))   # assign methods to plots\n            # \n            # if(is.na(xlims[1])|length(xlims)!=2){\n            #   xlims<-quantile(Data@TAC,c(0.005,0.95),na.rm=T)\n            #   if(xlims[1]<0)xlims[1]<-0\n            # }\n            # if(!NAor0(Data@Ref)){\n            #   if(xlims[1]>Data@Ref)xlims[1]<-max(0,0.98*Data@Ref)\n            #   if(xlims[2]<Data@Ref)xlims[2]<-1.02*Data@Ref\n            # }\n            # ylims<-c(0,1)\n            # \n            # #for(m in 1:nMPs){\n            # # if(sum(!is.na(Data@TAC[m,,1]))>2){\n            # # dens<-density(Data@TAC[m,,1],na.rm=T)\n            # #print(quantile(dens$y,0.99,na.rm=T))\n            # #  if(quantile(dens$y,0.9,na.rm=T)>ylims[2])ylims[2]<-quantile(dens$y,0.90,na.rm=T)\n            # #}\n            # #}\n            # \n            # #dev.new2(width=10,height=0.5+7*nplots)\n            # par(mfrow=c(ceiling(nplots/2),2),mai=c(0.4,0.4,0.01,0.01),omi=c(0.35,0.35,0.35,0.05))\n            # \n            # for(p in 1:nplots){\n            #   m<-mbyp[[p]][1]\n            #   plot(NA,NA,xlim=xlims,ylim=ylims,main=\"\",xlab=\"\",ylab=\"\",col=\"white\",lwd=3,type=\"l\")\n            #   abline(h=0)\n            #   if(!NAor0(Data@Ref)){\n            #     abline(v=Data@Ref,col=\"light grey\",lwd=2)\n            #     if(!NAor0(Data@Ref_type[1]))legend('right',Data@Ref_type,text.col=\"grey\",bty='n')\n            #   }\n            #   #plot(density(DLM@TAC[m,,1],from=0,na.rm=T),xlim=xlims,ylim=ylims,main=\"\",xlab=\"\",ylab=\"\",col=coly[m],lty=ltyy[m],type=\"l\")\n            #   \n            #   if(!is.na(perc[1]))abline(v=quantile(Data@TAC[m,,1],p=perc,na.rm=T),col=cols[m],lty=ltys[m])\n            #   #if(length(mbyp[[p]])>0){\n            #   for(ll in 1:length(mbyp[[p]])){\n            #     m<-mbyp[[p]][ll]\n            #     if(sum(!is.na(Data@TAC[m,,1]))>10){  # only plot if there are sufficient non-NA TAC samples\n            #       x<-density(Data@TAC[m,,1],from=0,na.rm=T)$x\n            #       y<-density(Data@TAC[m,,1],from=0,na.rm=T)$y\n            #       y<-y/max(y)\n            #       lines(x,y,col=cols[ll])\n            #     }else{\n            #       print(paste(\"Method \",funcs[m],\" produced too many NA TAC values for plotting densities\",sep=\"\"))\n            #     }\n            #     if(!is.na(perc[1]))abline(v=quantile(Data@TAC[m,,1],p=perc,na.rm=T),col=cols[ll],lty=2)\n            #   }\n            #   #}\n            #   cind<-1:length(mbyp[[p]])\n            #   legend('topright',funcs[mbyp[[p]]],text.col=cols[cind],col=cols[cind],lty=1,bty='n',cex=0.75)\n            # }\n            # \n            # mtext(paste(\"TAC (\",Data@Units,\")\",sep=\"\"),1,outer=T,line=0.5)\n            # mtext(paste(\"Standardized relative frequency\",sep=\"\"),2,outer=T,line=0.5)\n            # mtext(paste(\"TAC calculation for \",Data@Name,sep=\"\"),3,outer=T,line=0.5)\n          # })\n\n# # ---- Plot MSE object ----\n# #' Plot MSE object\n# #'\n# #' @rdname plot-MSE\n# #' @param x object of class MSE\n# #' @export\n# setMethod(\"plot\",\n#           signature(x = \"MSE\"),\n#           function(x){\n#             MSEobj<-x\n#             Pplot(MSEobj)\n#             Kplot(MSEobj)\n#             Tplot(MSEobj)\n#           })\n\n\n\n\n\n# ---- Summary of Data Object ----\n#' Summary of Data object\n#'\n#' @rdname summary-Data\n#' @param object object of class Data\n#' @export\nsetMethod(\"summary\",\n          signature(object = \"Data\"),\n          function(object){\n            \n            old_par <- par(no.readonly = TRUE)\n            on.exit(par(list = old_par), add = TRUE)\n            \n            scols<-c('red','green','blue','orange','brown','purple','dark grey','violet','dark red','pink','dark blue','grey')\n            \n            #dev.new2(width=8,height=4.5)\n            par(mai=c(0.35,0.9,0.2,0.01),c(0.3,0,0,0))\n            layout(matrix(c(1,2,1,2,1,2,3,3,3,3),nrow=2))\n            plot(object@Year,object@Cat[1,],col=\"blue\",type=\"l\",xlab=\"Year\",ylab=paste(\"Catch (\",object@Units,\")\",sep=\"\"),ylim=c(0,max(object@Cat[1,],na.rm=T)))\n            plot(object@Year,object@Ind[1,],col=\"orange\",type=\"l\",xlab=\"Year\",ylab=\"Relative abundance\",ylim=c(0,max(object@Ind[1,],na.rm=T)))\n            \n            slots<-c(\"Dep\",\"Mort\",\"FMSY_M\",\"Dt\",\"BMSY_B0\",\"vbK\")\n            namey<-c(\"Stock depletion\", \"Natural Mortality rate\",\"Ratio of FMSY to M\",\"Depletion over time t\",\"BMSY relative to unfished\",\"Von B. k parameter\")\n            slotsCV<-c(\"CV_Dep\",\"CV_Mort\",\"CV_FMSY_M\",\"CV_Dt\",\"CV_BMSY_B0\",\"CV_vbK\")\n            \n            ind<-rep(TRUE,length(slotsCV))\n            for(i in 1:length(slotsCV))if(NAor0(attr(object,slots[i]))|NAor0(attr(object,slotsCV[i])))ind[i]<-FALSE\n            slots<-slots[ind]\n            slotsCV<-slotsCV[ind]\n            nrep<-150\n            xstore<-array(NA,c(length(slots),nrep))\n            ystore<-array(NA,c(length(slots),nrep))\n            \n            \n            for(i in 1:length(slots)){\n              mu<-attr(object,slots[i])\n              cv<-attr(object,slotsCV[i])\n              xstore[i,]<-qlnorm(seq(0,1,length.out=nrep),mconv(mu,cv),sdconv(mu,cv))\n              ystore[i,]<-dlnorm(xstore[i,],mconv(mu,cv),sdconv(mu,cv))\n            }\n            \n            plot(xstore[1,],ystore[1,],type=\"l\",xlim=c(0,1.2),ylim=c(0,quantile(ystore,0.97)),xlab=\"\",ylab=\"Relative frequency\",col=scols[1])\n            if(length(slots)>1){\n              for(i in 2:length(slots)) lines(xstore[i,],ystore[i,],col=scols[i])\n            }\n            legend('topright',legend=namey[ind],text.col=scols[1:length(slots)],bty='n')\n            mtext(paste(\"Data summary for\",deparse(substitute(Data)),sep=\" \"),3,font=2,line=0.25,outer=T)\n            \n          })\n\n# ---- Summary of MSE object ----\n# Summary of MSE object\n#\n# @param object object of class MSE\n# @rdname summary-MSE\n# @export\n# # setMethod(\"summary\",\n# #           signature(object = \"MSE\"),\n# summaryold <- function(object){            \n#             \n#             MSEobj<-object      \n#             nm<-MSEobj@nMPs\n#             nsim<-MSEobj@nsim\n#             proyears<-MSEobj@proyears\n#             \n#             Yd<-P10<-P50<-P100<-POF<-LTY<-STY<-VY<-array(NA,c(nm,nsim))\n#             \n#             yind<-max(MSEobj@proyears-4,1):MSEobj@proyears\n#             RefYd<-MSEobj@OM$RefY\n#             yend<-max(MSEobj@proyears-9,1):MSEobj@proyears\n#             ystart<-1:10\n#             y1<-1:(MSEobj@proyears-1)\n#             y2<-2:MSEobj@proyears\n#             \n#             for(m in 1:nm){\n#               Yd[m,]<-round(apply(MSEobj@C[,m,yind],1,mean,na.rm=T)/RefYd*100,1)\n#               POF[m,]<-round(apply(MSEobj@F_FMSY[,m,]>1,1,sum,na.rm=T)/proyears*100,1)\n#               P10[m,]<-round(apply(MSEobj@B_BMSY[,m,]<0.1,1,sum,na.rm=T)/proyears*100,1)\n#               P50[m,]<-round(apply(MSEobj@B_BMSY[,m,]<0.5,1,sum,na.rm=T)/proyears*100,1)\n#               P100[m,]<-round(apply(MSEobj@B_BMSY[,m,]<1,1,sum,na.rm=T)/proyears*100,1)\n#               LTY[m]<-round(sum(MSEobj@C[,m,yend]/RefYd>0.5)/(MSEobj@nsim*length(yend))*100,1)\n#               STY[m]<-round(sum(MSEobj@C[,m,ystart]/RefYd>0.5)/(MSEobj@nsim*length(ystart))*100,1)\n#               AAVY<-apply(((MSEobj@C[,m,y1]-MSEobj@C[,m,y2])^2)^0.5,1,mean)/apply(MSEobj@C[,m,y2],1,mean)\n#               VY[m]<-round(sum(AAVY<0.1)/MSEobj@nsim*100,1)\n#             }\n#             nr<-2\n#             out<-cbind(MSEobj@MPs,round(apply(Yd,1,mean,na.rm=T),nr),round(apply(Yd,1,sd,na.rm=T),nr),\n#                        round(apply(POF,1,mean,na.rm=T),nr),round(apply(POF,1,sd,na.rm=T),nr),\n#                        round(apply(P10,1,mean,na.rm=T),nr),round(apply(P10,1,sd,na.rm=T),nr),\n#                        round(apply(P50,1,mean,na.rm=T),nr),round(apply(P50,1,sd,na.rm=T),nr),\n#                        round(apply(P100,1,mean,na.rm=T),nr),round(apply(P100,1,sd,na.rm=T),nr),\n#                        round(apply(LTY,1,mean,na.rm=T),nr),\n#                        round(apply(STY,1,mean,na.rm=T),nr),\n#                        round(apply(VY,1,mean,na.rm=T),nr))\n#             out<-as.data.frame(out)\n#             names(out)<-c(\"MP\",\"Yield\",\"stdev\",\"POF\",\"stdev \",\"P10\",\"stdev\",\n#                           \"P50\",\"stdev\",\"P100\",\"stdev\",\"LTY\",\"STY\",\"VY\")\n#             out[,1]<-as.character(out[,1])\n#             for(i in 2:ncol(out))out[,i]<-as.numeric(as.character(out[,i]))\n#             out\n#           }\n\n\n\n# # -- Input Control Recommendation Class -\n# #' Class \\code{'InputRec'}\n# #' \n# #' An object for storing the recommendation for an input control MP \n# #' \n# #' @name InputRec-class\n# #' @docType class\n# #' @section Objects from the Class: Objects can be created by calls of the form\n# #' \\code{new('InputRec')} \n# \n# #' @slot Effort A numeric value with the effort recommendation as a fraction of current (nyear) fishing effort\n# #' @slot Spatial A boolean vector of length 'nareas' specifying if area is open (1) or closed (0) to fishing \n# #' @slot Allocate A boolean value describing if effort should be re-allocated from close to open areas\n# #' @slot LR5 smallest length at 5 per cent retention\n# #' @slot LFR smallest length at full retention \n# #' @slot HS upper harvest slot (no retention above this)\n# #' @slot Rmaxlen retention of the largest size class\n# #' @slot Misc An empty list that can be used to store information and pass on to MPs in future \n# #' @author A. Hordyk\n# #' @keywords classes\n# \n# setClass(\"InputRec\", representation(Effort = \"numeric\", \n#                                     Spatial=\"numeric\", Allocate = \"numeric\", LR5 = \"numeric\",\n#                                     LFR = \"numeric\", HS=\"numeric\", Rmaxlen=\"numeric\", Misc=\"list\"))\n# setMethod(\"initialize\", \"InputRec\", function(.Object){\n#      .Object@Effort<-1\n#      .Object@Allocate<-1\n#      .Object@Spatial<-c(1,1)\n#      .Object\n#    })\n\n\n# -- Management Recommendation Class ----\n#' Class \\code{'Rec'}\n#' \n#' An object for storing the MP recommendations \n#' \n#' @name Rec-class\n#' @docType class\n#' @section Objects from the Class: Objects can be created by calls of the form\n#' \\code{new('Rec')} \n#' @slot TAC A numeric value with the TAC recommendation \n#' @slot Effort A numeric value with the effort recommendation as a fraction of current (nyear) fishing effort\n#' @slot Spatial A boolean vector of length 'nareas' specifying if area is open (1) or closed (0) to fishing \n#' @slot Allocate A boolean value describing if effort should be re-allocated from close to open areas\n#' @slot LR5 smallest length at 5 per cent retention - in absolute units - i.e same units as Linf and L50\n#' @slot LFR smallest length at full retention  - in absolute units - i.e same units as Linf and L50\n#' @slot HS upper harvest slot (no retention above this)  - in absolute units - i.e same units as Linf and L50\n#' @slot Rmaxlen retention of the largest size class - fraction between 0 and 1\n#' @slot L5 smallest length at 5 per cent selection - in absolute units - i.e same units as Linf and L50\n#' @slot LFS smallest length at full selection  - in absolute units - i.e same units as Linf and L50\n#' @slot Vmaxlen selection of the largest size class - fraction between 0 and 1\n#' @slot Fdisc fraction of discarded fish that die - fraction between 0 and 1\n#' @slot Misc An empty list that can be used to store information and pass on to MPs in future \n#' @author A. Hordyk\n#' @keywords classes\nsetClass(\"Rec\", representation(\n  TAC = \"numeric\",\n  Effort = \"numeric\", \n  Spatial=\"numeric\", Allocate = \"numeric\", \n  LR5 = \"numeric\", LFR = \"numeric\", HS=\"numeric\", Rmaxlen=\"numeric\", \n  L5 = \"numeric\", LFS = \"numeric\", Vmaxlen=\"numeric\", \n  Fdisc = \"numeric\",\n  Misc=\"list\"))\n\nsetMethod(\"initialize\", \"Rec\", function(.Object){\n  # .Object@TAC <- as.numeric(NA)\n  # .Object@Effort<-1\n  # .Object@Allocate<-1\n  # .Object@Spatial<-c(1,1)\n  .Object\n})\n\n#' Show the output of a single MP recommendation\n#'\n#' @param object object of class Rec\n#' @rdname show-Rec\n#' @export\nsetMethod(\"show\", signature = (object=\"Rec\"), function(object) {\n\n Rec <- object\n slots <- slotNames(Rec)\n recList <- list()\n perc <- 0.5\n for (X in slots) { # sequence along recommendation slots \n   if (X == \"Misc\") { # convert to a list nsim by nareas\n     rec <- slot(Rec, X)\n   } else {\n     rec <- slot(Rec,X) # unlist(lapply(temp, slot, name=X))\n   }\n   if (X == \"Spatial\") { # convert to a matrix nsim by nareas\n     nsims <- 1\n     nareas <- max(2,length(rec))\n     rec <- matrix(rec, nareas, nsims, byrow=FALSE)   \n   }\n   recList[[X]] <- rec\n }\n \n names <- c(\"TAC\", \"Effort\", \"LR5\", \"LFR\", \"HS\", \"Rmaxlen\",\n            \"L5\", \"LFS\", 'Vmaxlen', 'Spatial')\n mat <- matrix(0, nrow=1, ncol=length(names)+nareas-1)\n count <- 0 \n for (x in names) {\n   temp <- recList[[x]]\n   count <- count + 1 \n   if (x!=\"Spatial\") {\n     mat[,count] <- quantile(temp, probs=perc, na.rm=TRUE)\n   } else {\n     mat[,count:ncol(mat)] <- t(matrix(unlist(temp), nrow=nareas, ncol=1))\n   }\n }\n names[length(names)] <- \"Area 1\"\n names <- c(names, paste('Area', 2:nareas))\n if (perc !=0.5) names[1] <- paste0(names[1], ' (', perc, ' perc')\n if (perc ==0.5) names[1] <- paste0(names[1], ' (median)')\n colnames(mat) <- names\n \n if (nrow(mat) == 1) {\n   mat <- as.data.frame(mat)\n   matout <- mat[!is.na(mat)]\n   names(matout) <- names[!is.na(mat)]\n   print(matout)\n }\n})\n\n\n\n\n\n\n# #' Class \\code{'lmmodel'}\n# #'\n# #' An object for storing fitted linear model objects in this case the\n# #' relationship between M, age-at-maturity and the von B. K parameter.\n# #'\n# #'\n# #' @name lmmodel-class\n# #' @docType class\n# #' @section Objects from the Class: Objects can be created by calls of the form\n# #' \\code{new('lmmodel', stock)}. %% ~~ describe objects here ~~\n# #' @author T. Carruthers\n# #' @keywords classes\n# #' @examples\n# #'\n# #' newdata<-new('lmmodel','Name',new('list'))\n# #'\n# setClass(\"lmmodel\",representation(Name=\"character\",models=\"list\"))\n# # initialize lmmodel\n# setMethod(\"initialize\", \"lmmodel\", function(.Object,Name,models){\n#   .Object@Name<-Name\n#   .Object@models<-models\n#   .Object\n# })\n",
    "created" : 1519940944926.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4159078406",
    "id" : "BD80D8AB",
    "lastKnownWriteTime" : 1519682079,
    "last_content_update" : 1519682079,
    "path" : "C:/GitHub/DLMtool/R/DefineClasses.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}