{
    "collab_server" : "",
    "contents" : "#' State-Space Delay-Difference Stock Assessment in TMB with UMSY and MSY as leading parameters\n#'\n#' A delay-difference assessment that estimates the TAC using a\n#' time-series of catches and a relative abundance index and coded in TMB.\n#' Recruitment deviations from the stock-recruit relationship are estimated as a\n#' state space variable. The model is conditioned on effort and estimates\n#' predicted catch.\n#'\n#' @param x A position in a data-limited methods data object\n#' @param Data A data-limited methods data object\n#' @param reps The number of stochastic samples of the TAC recommendation\n#' @param report Indicates whether report will be produced for Data object.\n#' @return A numeric vector of TAC recommendations. If \\code{report = TRUE}, a list of\n#' model and TAC output is returned.\n#' @note Similar to many other assessment\n#' models it depends on assumptions such as stationary productivity and\n#' proportionality between the abundance index and real abundance.\n#' Unsurprisingly the extent to which these assumptions are\n#' violated tends to be the biggest driver of performance for this method.\n#' The observation error standard deviation is fixed according to the\n#' presumed CV of the catch and the process error (recruitment) standard deviation\n#' is estimated.\n#' @author Q. Huynh\n#' @references Method based on equations of Carl Walters (bug him with\n#' questions and expect colourful responses).\n#' @export DD_SS\n#' @seealso \\code{\\link{DD_TMB}}\n#' @import TMB\n#' @importFrom stats nlminb\n#' @importFrom mvtnorm rmvnorm\n#' @useDynLib MSEtool\nDD_SS <- function(x, Data, reps = 100, report = FALSE) {\n  dependencies = \"Data@vbLinf, Data@vbK, Data@vbt0, Data@Mort, Data@wla, Data@wlb, Data@Cat, Data@CV_Cat, Data@Ind\"\n  Winf = Data@wla[x] * Data@vbLinf[x]^Data@wlb[x]\n  age <- 1:Data@MaxAge\n  la <- Data@vbLinf[x] * (1 - exp(-Data@vbK[x] * ((age - Data@vbt0[x]))))\n  wa <- Data@wla[x] * la^Data@wlb[x]\n  a50V <- iVB(Data@vbt0[x], Data@vbK[x], Data@vbLinf[x],  Data@L50[x])\n  a50V <- max(a50V, 1)\n  yind <- (1:length(Data@Cat[x, ]))[!is.na(Data@Cat[x, ] + Data@Ind[x,   ])]\n  C_hist <- Data@Cat[x, yind]\n  E_hist <- C_hist/Data@Ind[x, yind]\n  E_hist <- E_hist/mean(E_hist)\n  ny_DD <- length(C_hist)\n  k_DD <- ceiling(a50V)  # get age nearest to 50% vulnerability (ascending limb)\n  k_DD[k_DD > Data@MaxAge/2] <- ceiling(Data@MaxAge/2)  # to stop stupidly high estimates of age at 50% vulnerability\n  Rho_DD <- (wa[k_DD + 2] - Winf)/(wa[k_DD + 1] - Winf)\n  Alpha_DD <- Winf * (1 - Rho_DD)\n  So_DD <- exp(-Data@Mort[x])  # get So survival rate\n  wa_DD <- wa[k_DD]\n  UMSYpriorpar <- c(1 - exp(-Data@Mort[x] * 0.5), 0.3) # Prior for UMSY is that corresponding to F = 0.5 M with CV = 0.3\n  UMSYprior <- c(alphaconv(UMSYpriorpar[1], prod(UMSYpriorpar)), betaconv(UMSYpriorpar[1], prod(UMSYpriorpar))) # Convert to beta parameters\n  AvC <- mean(C_hist, na.rm = TRUE)\n  sigmaC <- max(0.05, sdconv(AvC, AvC * Data@CV_Cat[x]))\n\n  data <- list(model = \"DD_SS\", So_DD = So_DD, Alpha_DD = Alpha_DD, Rho_DD = Rho_DD, ny_DD = ny_DD, k_DD = k_DD,\n               wa_DD = wa_DD, E_hist = E_hist, C_hist = C_hist, UMSYprior = UMSYprior)\n  params <- list(logit_UMSY_DD = log(UMSYpriorpar[1]/(1 - UMSYpriorpar[1])),\n                 log_MSY_DD = log(3 * AvC), log_q_DD = log(Data@Mort[x]),\n                 log_sigma_DD = log(sigmaC),\n                 log_tau_DD = log(0.3), log_rec_dev = rep(0, ny_DD - k_DD))\n  info <- list(data = data, params = params)\n\n  obj <- MakeADFun(data = info$data, parameters = info$params, random = 'log_rec_dev',\n                   map = list(log_sigma_DD = factor(NA)), DLL = \"MSEtool\", silent = TRUE)\n  opt <- nlminb(start = obj$par, objective = obj$fn, gradient = obj$gr)\n\n  if(reps == 1) TAC <- obj$report()$TAC\n  if(reps > 1) {\n    SD <- sdreport(obj, getReportCovariance = FALSE)\n    samps <- rmvnorm(reps, opt$par, round(SD$cov.fixed, 4))\n    TAC <- rep(NA, reps)\n    for (i in 1:reps) {\n      params.new <- list(logit_UMSY_DD = samps[i, 1], log_MSY_DD = samps[i, 2],\n                         log_q_DD = samps[i, 3], log_sigma_DD = log(sigmaC),\n                         log_tau_DD = samps[i, 4],\n                         log_rec_dev = obj$report()$log_rec_dev)\n      obj.samp <- MakeADFun(data = info$data, parameters = params.new, DLL = \"MSEtool\")\n      TAC[i] <- obj.samp$report()$TAC\n    }\n  }\n  Rec <- new(\"Rec\")\n  Rec@TAC <- TACfilter(TAC)\n\n  if(report) {\n    return(list(Rec = Rec, TAC = TAC, info = info, obj = obj, opt = opt,\n                Data = Data, dependencies = dependencies))\n  } else {\n    return(Rec)\n  }\n}\nclass(DD_SS) <- \"MP\"\n\n\n",
    "created" : 1519859013246.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "732058778",
    "id" : "86E8F3BF",
    "lastKnownWriteTime" : 1519859047,
    "last_content_update" : 1519859047893,
    "path" : "C:/GitHub/MSE/R/DD_SS.R",
    "project_path" : "R/DD_SS.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}